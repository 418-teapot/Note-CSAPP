\chapter{程序的机器级表示}

计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的管理，经过一系列的阶段生成机器代码。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

\section{历史观点}

Intel 处理器系列俗称 x86,经历了一个长期的、不断进化的发展过程。

8086 是第一代单芯片、16位微处理器；i386 将体系结构扩展到 32 位，增加了平坦寻址模式（flat addressing model）；Pentium III 引入了 SSE 指令；Pentium 4 扩展到了 SSE2；Pentium 4E 增加了超线程；Core i7 Nehalem 同时支持超线程和多核；Core i7 Sandy Bridge 引入了 AVX；Core i7 Haswell 扩展到了 AVX2。

\section{程序编码}

\subsection{机器级代码}

计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。第一种是 ISA 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA，包括 x86，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

在整个编译过程中，编译器会完成大部分的工作，将把 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。x86-64 的机器代码和原始的 C 代码差别很大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：

\begin{itemize}
    \item 程序计数器（PC，在 x86-64 中用 \verb|%rip| 来表示）给出要执行的下一条指令在内存中的地址。
    \item 整数寄存器堆（共 16 个寄存器），分别存储 64 位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
    \item 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息，通常用于控制流或者条件传送。
    \item 一组向量寄存器可以存放一个或多个整数或浮点数值。
\end{itemize}

\subsection{代码示例}

假设 C 语言代码文件 \verb|mstore.c|：

\begin{cppcode}
long mult2(long, long);

void multstore(long x, long y, long *dest) {
  long t = mult2(x, y);
  *dest = t;
}
\end{cppcode}

在命令行上使用 \verb|-S| 选项，就能看到产生的汇编代码：\verb|gcc -Og -S mstore.c| 或者 \verb|clang -Og -S mstore.c|。

汇编代码文件包含各种声明，包含下面几行：

\begin{gascode}
multstore:
    pushq   %rbx
    movq    %rdx, %rbx
    callq   mult2
    movq    %rax, (%rbx)
    popq    %rbx
    retq
\end{gascode}

如果使用 \verb|-c| 选项，会编译并汇编该代码：\verb|gcc -Og -c mstore.c| 或者 \verb|clang -Og -c mstore.c|。

这就会产生目标代码文件 \verb|mstore.o|，它是二进制格式的，所以无法直接查看。

\marginpar{\footnotesize 要展示程序（比如 mstore）的二进制目标代码，可以用反汇编器确定该过程的代码长度是 14 字节。然后，在文件 mstore.o 上运行调试工具 GDB，输入命令：x/14xb multstore。这条命令会让调试器显示从函数 multstore 所处地址开始的 14 个十六进制格式表示的字节。}

要查看机器代码文件的内容，有一类称为反汇编器（disassembler）的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。\verb|objdump -d mstore.o| 或者\\ \verb|llvm-objdump -d mstore.o|。

结果如下：

\begin{textcode}
0000000000000000 multstore:
    0: 53                               pushq   %rbx
    1: 48 89 d3                         movq    %rdx, %rbx
    4: e8 00 00 00 00                   callq   0 <multstore+0x9>
    9: 48 89 03                         movq    %rax, (%rbx)
    c: 5b                               popq    %rbx
    d: c3                               retq
\end{textcode}

其中一些关于机器代码和它的反汇编表示的特性值得主义：

\begin{itemize}
    \item x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少额度指令所需的字节数少，而哪些不太常用或操作数较多的指令所需字节数较多。
    \item 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。
    \item 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它不需要访问该程序的源代码或者汇编代码。
    \item 反汇编器使用的指令命名规则可能与生成的汇编代码有一些细微的区别（常见于 objdump 和 GCC）。
\end{itemize}

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须包含有一个 \verb|main| 函数。假设有文件 \verb|main.c|：

\begin{cppcode}
#include <stdio.h>

void multstore(long, long, long *);

int main() {
  long d;
  multstore(2, 3, &d);
  printf("2 * 3 --> %ld\n", d);
  return 0;
}
long mult2(long a, long b) {
  long s = a * b;
  return s;
}
\end{cppcode}

然后，生成可执行文件 \verb|prog|：\verb|clang -Og -o prog main.c mstore.c|。文件 \verb|prog| 的体积变得很大，因为它不仅包含了两个函数的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。反汇编 \verb|prog| 文件：\verb|llvm-objdump -d prog|。

反汇编器会抽取出各种代码序列，包括下面这段：

\begin{textcode}
0000000000401170 multstore:
  401170: 53                            pushq   %rbx
  401171: 48 89 d3                      movq    %rdx, %rbx
  401174: e8 e7 ff ff ff                callq   -25 <mult2>
  401179: 48 89 03                      movq    %rax, (%rbx)
  40117c: 5b                            popq    %rbx
  40117d: c3                            retq
  40117e: 66 90                         nop
\end{textcode}

这段代码与 \verb|mstore.c| 反汇编产生的代码几乎完全一样。其中一个主要的区别是左边列出的地址不同（链接器将这段代码的地址移到了一段不同的地址范围中）。第二个不同之处在于链接器填上了 \verb|callq| 指令调用函数 \verb|mult2| 需要使用的地址。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是多了一条 \verb|nop| 指令，插入 \verb|nop| 的作用是为了使函数代码变为 16 字节，使得就存储器系统性能而言，能够更好地放置下一个代码块。

\subsection{关于格式的注解}

所有以 \verb|.| 开头的都是指导汇编器和链接器工作的伪指令。通常可以忽略。

\subsubsection{AT\&T 与 Intel 汇编代码格式}

我们的表述是 AT\&T 格式的汇编代码，这是 GCC、OBJDUMP 等工具的默认格式。微软的工具和 Intel 的文档，其汇编代码是 Intel 格式的。可以使用 \verb|clang -Og -S -masm=intel mstore.c| 产生 \verb|multstore| 函数的 Intel 格式的代码：

\begin{nasmcode}
multstore:
    push    rbx
    mov     rbx, rdx
    call    mult2@PLT
    mov     qword ptr [rbx], rax
    pop     rbx
    ret
\end{nasmcode}

可以看到 Intel 和 AT\&T 格式再如下方面有所不同：

\begin{itemize}
    \item Intel 格式省略了指示大小的后缀（push 而非 pushq）。
    \item Intel 格式省略了寄存器名字前面的 \verb|%| 号。
    \item Intel 格式用不同大方式来描述内存中的位置（\verb|qword ptr [rbx]| 而非 \verb|(%rbx)|）。
    \item 在带有多个操作数的指令情况下，列出操作数的顺序相反。
\end{itemize}

\section{数据格式}

由于 x86 是从 16 位体系结构扩展而来的，Intel 用术语字（word）表示 16 位数据类型，因此，称 32 位数为 double words 或 long word，称 64 位数为 quad words。AT\&T 格式的汇编代码指令大部分都有一个字符的后缀，表明操作数的大小，如下表所示。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llcc}
        \toprule
        C declaration & Intel data type & Assembly-code suffix & Size(bytes) \\
        \midrule
        char    & Byte              & \verb|b|  & 1 \\
        short   & Word              & \verb|w|  & 2 \\
        int     & Double word       & \verb|l|  & 4 \\
        long    & Quad word         & \verb|q|  & 8 \\
        char *  & Quad word         & \verb|q|  & 8 \\
        float   & Single precision  & \verb|s|  & 4 \\
        double  & Double precision  & \verb|l|  & 8 \\
        \bottomrule
    \end{tabular}
\end{table}

注意，Double word 和 Double precision 使用同样的后缀 \verb|l|，这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

\section{访问信息}

一个 x86-64 的 CPU 包含一组 16 个 64 位值的通用寄存器，用来存储整数数据和指针，它们的名字都以 \verb|%r| 开头，最初的 8086 有 8 个 16 位的寄存器，即图中的 \verb|%ax| 到 \verb|%bp|。每个寄存器都有特殊的用途，它们的名字就反映了它们的用途。扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 \verb|%eax| 到 \verb|%ebp|。扩展到 x86-64 后，同样扩展成 64 位寄存器，标号从 \verb|%rax| 到 \verb|%rbp|。除此之外，还增加了 8 个新的寄存器，它们的标号时按照新的命名规则指定的，从 \verb|%r8| 到 \verb|%r15|。

\begin{figure}[!p]
    \centering
    \begin{tikzpicture}
        \foreach \r/\e/\w/\b/\t [count=\x] in {
            rax/eax/ax/al/Return value,
            rbx/ebx/bx/bl/Callee saved,
            rcx/ecx/cx/cl/4th argument,
            rdx/edx/dx/dl/3rd argument,
            rsi/esi/si/sil/2nd argumrnt,
            rdi/edi/di/dil/1st argument,
            rbp/ebp/bp/bpl/Callee saved,
            rsp/esp/sp/spl/Stack pointer,
            r8/r8d/r8w/r8b/5th argument,
            r9/r9d/r9w/r9b/6th argument,
            r10/r10d/r10w/r10b/Caller saved,
            r11/r11d/r11w/r11b/Caller saved,
            r12/r12d/r12w/r12b/Callee saved,
            r13/r13d/r13w/r13b/Callee saved,
            r14/r14d/r14w/r14b/Callee saved,
            r15/r15d/r15w/r15b/Callee saved
        } {
            \draw[fill=White!60!ProcessBlue] (0, -1.4 * \x + 0.5) rectangle (16, -1.4 * \x - 0.5);
            \draw[fill=White!90!ProcessBlue] ($(8, -1.4 * \x + 0.5) + (0, -2pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-2pt, 2pt)$);
            \draw[fill=White] ($(12, -1.4 * \x + 0.5) + (0, -4pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-4pt, 4pt)$);
            \draw[fill=White, thick] ($(14, -1.4 * \x + 0.5) + (0, -6pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-6pt, 6pt)$);
            \node[right] at (0, -1.4 * \x) {\texttt{\%\r}};
            \node[right] at (8, -1.4 * \x) {\texttt{\%\e}};
            \node[right] at (12, -1.4 * \x) {\texttt{\%\w}};
            \node[right] at (14, -1.4 * \x) {\texttt{\%\b}};
            \node[right] at (16, -1.4 * \x) {\t};
        }
        \node[above] at (0, -0.5) {63};
        \node[above] at (8, -0.5) {31};
        \node[above] at (12, -0.5) {15};
        \node[above] at (14, -0.5) {7};
        \node[above] at (16, -0.5) {0};
    \end{tikzpicture}
\end{figure}

\subsection{操作数指示符}

大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64 支持多种操作格式。第一种类型是立即数（immediate），用来表示常数值。在 AT\&T 格式的汇编代码中，立即数的书写方式是 \$ 后面跟一个用标准 C 表示法表示的整数。第二种类型是寄存器（register），表示某个寄存器的内容。我们用符号 $r_a$ 来表示任意寄存器 $a$，用引用 $R[r_a]$ 来表示它的值。第三种操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。我们用符号 $M_b[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始的 $b$ 个字节值的引用。为了简便，通常省去下标 $b$。

如下表所示，x86-64 还支持多种寻址模式。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        Type & Form & Operand value & Name \\
        \midrule
        Immediate & \$$Imm$ & $Imm$ & Immediate \\
        \\
        Register & $r_a$ & $R[r_a]$ & Register \\
        \\
        Memory & $Imm$              & $M[Imm]$                              & Absolute \\
        Memory & $(r_a)$            & $M[R[r_a]]$                           & Indirect \\
        Memory & $Imm(r_b)$         & $M[Imm + R[r_b]]$                     & Base + displacement \\
        Memory & $(r_b, r_i)$       & $M[R[r_b] + R[r_i]]$                  & Indexed \\
        Memory & $Imm(r_b, r_i)$    & $M[Imm + R[r_b] + R[r_i]]$            & Indexed \\
        Memory & $(, r_i, s)$       & $M[R[r_i] \cdot s]$                   & Scaled indexed \\
        Memory & $Imm(, r_i, s)$    & $M[Imm + R[r_i] \cdot s]$             & Scaled indexed \\
        Memory & $(r_b, r_i, s)$    & $M[R[r_b] + R[r_i] \cdot s]$          & Scaled indexed \\
        Memory & $Imm(r_b, r_i, s)$ & $M[Imm + R[r_b] + R[r_i] \cdot s]$    & Scaled indexed \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{数据传送指令}

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

MOV 类指令将数据从原位置复制到目的位置，不做任何变化。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        MOV                & $S, D$ & $D \leftarrow S$  & Move \\
        \quad\texttt{movb} &        &                   & Move byte \\
        \quad\texttt{movw} &        &                   & Move word \\
        \quad\texttt{movl} &        &                   & Move double word \\
        \quad\texttt{movq} &        &                   & Move quad word \\
        \texttt{movabsq}   & $I, R$ & $R \leftarrow I$  & Move absolute word \\
        \bottomrule
    \end{tabular}
\end{table}

\marginpar{\footnotesize 造成这个例外的原因是 x86-64 采用的惯例，即任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分设置为 0。}

源操作数可以是立即数、寄存器或者内存中的值，目的操作数可以是寄存器或者是内存地址。x86-64 限制 传送指令的两个操作数不能同时指向内存。大多数情况下，MOV 指令只会更新目的操作数指定的寄存器字节或者内存位置。唯一的例外是 \verb|movl| 指令以寄存器作为目的时。它会把该寄存器的高 4 字节设置为 0。

MOVZ 类指令把目的中剩余的字节填充为 0,而 MOVS 类指令填充为符号位。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        Instruction & Effect & Description \\
        \midrule
        MOVZ \quad $S, R$ & $R \leftarrow ZeroExtend(S)$ & Move with zero extension \\
        \quad\texttt{movzbw} & & Move zero-extended byte to word \\
        \quad\texttt{movzbl} & & Move zero-extended byte to double word \\
        \quad\texttt{movzwl} & & Move zero-extended word to doubel word \\
        \quad\texttt{movzbq} & & Move zero-extended byte to quad word \\
        \quad\texttt{movzwq} & & Move zero-extended word to quad word \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        Instruction & Effect & Description \\
        \midrule
        MOVS \quad $S, R$ & $R \leftarrow SignExtend(S)$ & Move with sign extension \\
        \quad\texttt{movsbw} & & Move sign-extended byte to word \\
        \quad\texttt{movsbl} & & Move sign-extended byte to double word \\
        \quad\texttt{movswl} & & Move sign-extended word to double word \\
        \quad\texttt{movsbq} & & Move sign-extended byte to quad word \\
        \quad\texttt{movswq} & & Move sign-extended word to quad word \\
        \quad\texttt{movslq} & & Move sign-extended double to quad word \\
        \texttt{cltq} & $\texttt{\%rax} \leftarrow SignExtend(\texttt{\%eax})$ & Sign-extend \texttt{\%eax} to \texttt{\%rax} \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{数据传送示例}

略。

\subsection{压入和弹出栈数据}

栈是一种数据结构，可以添加或者删除值，遵循后进先出的原则。通过 push 操作把数据压入栈中，通过 pop 操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一段插入和删除元素。这一端被称为栈顶。x86-64 中，程序栈存放在内存中某个区域。栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址最低的。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{pushq} & $S$ & $R[\texttt{\%rsp}] \leftarrow R[\texttt{\%rsp}] - 8$; & Push quad word \\
        & & $M[R[\texttt{\%rsp}]] \leftarrow S$ & \\
        \texttt{popq} & $D$ & $D \leftarrow M[R[\texttt{\%rsp}]]$; & Pop quad word \\
        & & $R[\texttt{\%rsp}] \leftarrow R[\texttt{\%rsp}] + 8$ & \\
        \bottomrule
    \end{tabular}
\end{table}

\verb|pushq| 指令的功能是把数据压入到栈上，而 \verb|popq| 指令是弹出数据，这两条指令都只有一个操作数。

\section{算术和逻辑操作}

下表列出了 x86-64 的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有四种带不同大小操作数的变种。\marginpar{\footnotesize 只有 \texttt{leaq} 没有其他大小的变种。}这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{leaq} & $S, D$ & $D \leftarrow \&S$ & Load effective address \\
        \\
        INC  & $D$    & $D \leftarrow D + 1$    & Increment \\
        DEC  & $D$    & $D \leftarrow D - 1$    & Decrement \\
        NEG  & $D$    & $D \leftarrow -D$       & Negate \\
        NOT  & $D$    & $D \leftarrow \~{}D$    & Complement \\
        \\
        ADD  & $S, D$ & $D \leftarrow D + S$    & Add \\
        SUB  & $S, D$ & $D \leftarrow D - S$    & Subtract \\
        IMUL & $S, D$ & $D \leftarrow D * S$    & Multiply \\
        XOR  & $S, D$ & $D \leftarrow D \^{} S$ & Exclusive-or \\
        OR   & $S, D$ & $D \leftarrow D | S$    & Or \\
        AND  & $S, D$ & $D \leftarrow D \& S$   & And \\
        \\
        SAL  & $k, D$ & $D \leftarrow D << k$ & Left shift \\
        SHL  & $k, D$ & $D \leftarrow D << k$ & Left shift(same as SAL) \\
        SAR  & $k, D$ & $D \leftarrow D >>_A k$ & Arithmetic right shift \\
        SHR  & $k, D$ & $D \leftarrow D >>_L k$ & Logical right shift \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{加载有效地址}

load effective address 指令 \verb|leaq| 实际上是 \verb|movq| 指令的变形，该指令的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。另外，它还可以简洁地描述普通的算术操作。编译器经常利用 \verb|leaq| 的一些灵活用法，根本就与有效地址计算无关。例如：

\begin{cppcode}
long scale(long x, long y, long z) {
  long t = x + 4 * y + 12 * z;
  return t;
}
\end{cppcode}

编译时，该函数的算术运算以三条 \verb|leaq| 指令实现：

\begin{gascode}
# long scale(long x, long y, long z)
# x in %rdi, y in %rsi, z in %rdx
scale:
    leaq    (%rdi,%rsi,4), %rax     # x + 4*y
    leaq    (%rdx,%rdx,2), %rcx     # z + 2*z = 3*z
    leaq    (%rax,%rcx,4), %rax     # (x+4*y) + 4*(3*z) = x + 4*y + 12*z
    retq
\end{gascode}

\subsection{一元和二元操作}

一元操作只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。二元操作有两个操作数，其中第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或者内存位置，第二个操作数可以是寄存器或者内存位置。

\subsection{移位操作}

移位操作的第一个操作数是移位量，第二个操作数是要移位的数。移位量可以是一个立即数，或者放在单字节寄存器 \verb|%cl| 中。

\subsection{讨论}

大多数指令，既可以用于无符号运算，又可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算可以实现有符号整数运算。

\subsection{特殊的算术运算}

2 个 64 位有符号或者无符号整数相乘得到的乘积需要 128 位来表示，x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。Intel 把 16 字节的数称为 oct word。下表展示了产生 128 位数的指令：

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{imulq} & $S$ & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow S \times R[\texttt{\%rax}]$ & Signed full multiply \\
        \texttt{mulq} & $S$ & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow S \times R[\texttt{\%rax}]$ & Unsigned full multiply \\
        \\
        \texttt{cqto} & & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow SignExtend(R[\texttt{\%rax}])$ & Convert to oct word \\
        \\
        \texttt{idivq} & $S$ & $R[\texttt{\%rdx}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \bmod S$; & Signed divide \\
        & & $R[\texttt{\%rax}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \div S$ & \\
        \texttt{divq} & $S$ & $R[\texttt{\%rdx}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \bmod S$; & Unsigned divide \\
        & & $R[\texttt{\%rax}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \div S$ & \\
        \bottomrule
    \end{tabular}
\end{table}

\verb|imulq| 指令有两种不同的形式。其中一种，是 IMUL 指令类中的一种。这种形式的 \verb|imulq| 指令是一个双操作数乘法指令，它从两个 64 位操作数产生一个 64 位乘积。

此外，x86-64 还提供了两条单操作数乘法指令，以计算两个 64 位数的全 128 位乘积，都要求一个参数必须在寄存器 \verb|%rax| 中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器 \verb|%rdx|（高 64 位）和 \verb|%rax|（低 64 位）中。

前面的算术运算表没有列出除法或取模操作。这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。

\section{控制}

\subsection{条件码}

除了整数寄存器，x86-64 CPU 还维护着一组单个位的条件码（condition code）寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：
\begin{itemize}
    \item \verb|CF|: Carry flag 最近的操作使最高位产生了进位。
    \item \verb|ZF|: Zero flag 最近的操作得出的结果为 0。
    \item \verb|SF|: Sign flag 最近的操作得出的结果为负数。
    \item \verb|OF|: Overflow flag 最近的操作导致一个补码溢出。
\end{itemize}

\verb|leaq| 指令不会改变任何条件码，除此之外，所有运算指令都会设置条件码。还有两类指令只设置条件码而不改变任何其他寄存器：CMP 指令根据两个操作数之差设置条件码，TEST 指令根据两个操作数的与设置条件码。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Based on & Description \\
        \midrule
        CMP & $S1, S2$ & $S2 - S1$ & Compare \\
        \quad\texttt{cmpb} & & & Compare byte \\
        \quad\texttt{cmpw} & & & Compare word \\
        \quad\texttt{cmpl} & & & Compare double word \\
        \quad\texttt{cmpq} & & & Compare quad word \\
        TEST & $S1, S2$ & $S1 \& S2$ & Test \\
        \quad\texttt{testb} & & & Test byte \\
        \quad\texttt{testw} & & & Test word \\
        \quad\texttt{testl} & & & Test double word \\
        \quad\texttt{testq} & & & Test quad word \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{访问条件码}

条件码通常不会直接读取，常用的使用方法有三种：1）根据条件码的某种组合，将一个字节设置为 0 或者 1；2）条件跳转到程序的其他位置；3）条件传送数据。

对于第一种情况，该类指令称为 SET 指令，一条 SET 指令的目的操作数是低位单字节寄存器或者单字节的内存位置。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lllll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Synonym & Effect & Set Condition \\
        \midrule
        \texttt{sete}  & $D$ & \texttt{setz}  & $D \leftarrow ZF$     & Equal / zero \\
        \texttt{setne} & $D$ & \texttt{setnz} & $D \leftarrow \~{}ZF$ & Not equal / not zero \\
        \\
        \texttt{sets}  & $D$ & & $D \leftarrow SF$     & Negative \\
        \texttt{setns} & $D$ & & $D \leftarrow \~{}SF$ & Nonnegative \\
        \\
        \texttt{setg}  & $D$ & \texttt{setnle} & $D \leftarrow \~{}(SF\^{}OF)\&\~{}ZF$ & Greater (signed >) \\
        \texttt{setge} & $D$ & \texttt{setnl}  & $D \leftarrow \~{}(SF\^{}OF)$         & Greater or equal(signed >=) \\
        \texttt{setl}  & $D$ & \texttt{setnge} & $D \leftarrow SF\^{}OF$               & Less (signed <) \\
        \texttt{setle} & $D$ & \texttt{setng}  & $D \leftarrow (SF\^{}OF)|ZF$          & Less or equal (signed <=) \\
        \\
        \texttt{seta}  & $D$ & \texttt{setnbe} & $D \leftarrow \~{}CF\&\~{}ZF$ & Above (unsigned >) \\
        \texttt{setae} & $D$ & \texttt{setnb}  & $D \leftarrow \~{}CF$         & Above or equal (unsigned >=) \\
        \texttt{setb}  & $D$ & \texttt{setnae} & $D \leftarrow CF$             & Below (unsigned <) \\
        \texttt{setbe} & $D$ & \texttt{setna}  & $D \leftarrow CF|ZF$          & Below or equal (unsigned <=) \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{跳转指令}

jump 指令会让程序在执行时切换到一个全新的位置，在汇编代码中，这些跳转的目的地通常用一个 label 指明。下表列出了不同的跳转指令。\verb|jmp| 指令是无条件跳转，可以是直接跳转，也可以是间接跳转。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lllll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Synonym & Jump condition & Description \\
        \midrule
        \texttt{jmp} & $Label$ & & 1 & Direct jump \\
        \texttt{jmp} & $*Operand$ & & 1 & Indirect jump \\
        \texttt{je}  & $Label$ & \texttt{jz}  & $ZF$ & Equal / zero \\
        \texttt{jne} & $Label$ & \texttt{jnz} & $\~{}ZF$ & Not equal / not zero \\
        \texttt{js}  & $Label$ &              & $SF$ & Negative \\
        \texttt{jns} & $Label$ &              & $\~{}SF$ & Nonnegative \\
        \texttt{jg}  & $Label$ & \texttt{jnle} & $\~{}(SF\^{}OF)\&\~{}ZF$ & Greater (signed >) \\
        \texttt{jge} & $Label$ & \texttt{jnl}  & $\~{}(SF\^{}OF)$         & Greater or equal (signed >=) \\
        \texttt{jl}  & $Label$ & \texttt{jnge} & $SF\^{}OF$               & Less (signed <) \\
        \texttt{jle} & $Label$ & \texttt{jng}  & $(SF\^{}OF)|ZF$          & Less or equal (signed <=) \\
        \texttt{ja}  & $Label$ & \texttt{jnbe} & $\~{}CF\&\~{}ZF$         & Above (unsigned >) \\
        \texttt{jae} & $Label$ & \texttt{jnb}  & $\~{}CF$                 & Above or equal (unsigned >=) \\
        \texttt{jb}  & $Label$ & \texttt{jnae} & $CF$                     & Below (unsigned <) \\
        \texttt{jbe} & $Label$ & \texttt{jna}  & $CF|ZF$                  & Below or equal (unsigned <=) \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{跳转指令的编码}

在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码，跳转地址由 PC-relative 和绝对地址两种。

当执行 PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。这种管理可以追溯到早期的实现，当时的处理器会将更新程序计数器作为执行一条指令的第一步。

PC 相对寻址的好处：指令编码简洁，方便重定位，目标代码可以不做改变就能移动到内存中不同的位置。

\subsection{用条件控制来实现条件分支}

将条件表达式和语句从 C 语言翻译成机器语言，最常用的方式是结合有条件和无条件跳转。

C 语言中的 \verb|if-else| 语句的通用形式模板如下：

\begin{cppcode}
if (test-expr)
  then-statement
else
  else-statement
\end{cppcode}

这里的 \verb|test-expr| 是一个整数表达式，它的取值为 0 或者非 0。两个分支语句中只会执行一个。

对于这种通用形式，汇编实现通常会使用下面这种形式，这里，我们用 C 语法来描述控制流：

\begin{cppcode}
  t = test-expr;
  if (!t)
    goto done;
false:
  else-statement
done:
\end{cppcode}

也就是，汇编器为 \verb|then-statement| 和 \verb|else-statement| 产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。

\subsection{用条件传送来实现条件分支}

实现条件操作的传统方法是通过使用控制的条件转移。一种替代的策略是使用数据额条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选择一个。

下表列出了 x86-64 上一些可用的条件传送指令，源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lllll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Synonym & Move condition & Description \\
        \midrule
        \texttt{cmove}  & $S, R$ & \texttt{cmovz}   & $ZF$ & Equal / zero \\
        \texttt{cmovne} & $S, R$ & \texttt{cmovnz}  & $\~{}ZF$ & Not equal / not zero \\
        \texttt{cmovs}  & $S, R$ &                  & $SF$ & Negative \\
        \texttt{cmovns} & $S, R$ &                  & $\~{}SF$ & Nonnegative \\
        \texttt{cmovg}  & $S, R$ & \texttt{cmovnle} & $\~{}(SF\^{}OF)\&\~{}ZF$ & Greater (signed >) \\
        \texttt{cmovge} & $S, R$ & \texttt{cmovnl}  & $\~{}(SF\^{}OF)$         & Greater or equal (signed >=) \\
        \texttt{cmovl}  & $S, R$ & \texttt{cmovnge} & $SF\^{}OF$               & Less (signed <) \\
        \texttt{cmovle} & $S, R$ & \texttt{cmovng}  & $(SF\^{}OF)|ZF$          & Less or equal (signed <=) \\
        \texttt{cmova}  & $S, R$ & \texttt{cmovnbe} & $\~{}CF\&\~{}ZF$         & Above (unsigned >) \\
        \texttt{cmovae} & $S, R$ & \texttt{cmovnb}  & $\~{}CF$                 & Above or equal (unsigned >=) \\
        \texttt{cmovb}  & $S, R$ & \texttt{cmovnae} & $CF$                     & Below (unsigned <) \\
        \texttt{cmovbe} & $S, R$ & \texttt{cmovna}  & $CF|ZF$                  & Below or equal (unsigned <=) \\
        \bottomrule
    \end{tabular}
\end{table}

考虑下面的条件表达式和赋值的通用形式：\cppinline{v = test-expr ? then-epxr : else-expr;}

用条件控制转移的标准方法来编译这个表达式会得到如下形式：

\begin{cppcode}
  if (!text-expr)
    goto false;
  v = then-expr;
  goto done;
false:
  v = else-expr;
done:
\end{cppcode}

基于条件传送的代码，会对 \verb|then-expr| 和 \verb|else-expr| 都求值，最终值的选择基于对 \verb|test-expr| 的求值。可以用下面的抽象代码描述：
\begin{cppcode}
v = then-expr;
ve = else-expr;
t = test-expr;
if (!t) v = ve;
\end{cppcode}
这个序列的最后一条语句是用条件传送指令实现的。

不是所有的条件表达式都可以用条件传送来编译。最重要的是，无论测试结果如何，我们给出的抽象代码会对 \verb|then-expr| 和 \verb|else-epxr| 都求值。如果这两个表达式中的任意一个产生错误或者副作用，就会导致未预期的行为。

\subsection{循环}

C 语言提供了多种循环结构，即 \verb|do-while|、\verb|while| 和 \verb|for|。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。

\subsubsection{do-while 循环}

\verb|do-while| 语句的通用形式如下：
\begin{cppcode}
do
  body-statement
  while (test-expr);
\end{cppcode}
这个循环的效果就是重复执行 \verb|body-statement|，对 \verb|test-expr| 求值，如果求值的结果为非 0，就继续循环。可以看到，\verb|body-statement| 至少会执行一次。

这种通用形式可以被翻译成如下所示的条件和 \verb|goto| 语句：
\begin{cppcode}
loop:
  body-statement
  t = test-expr;
  if (t)
    goto loop;
\end{cppcode}

\subsubsection{while 循环}

\verb|while| 语句的通用形式如下：
\begin{cppcode}
while (test-expr)
  body-statement
\end{cppcode}
与 \verb|do-while| 的不同之处在于，在第一次执行 \verb|body-statement| 之前，它会对 \verb|test-expr| 求值，循环有可能在执行之前就中止了。有很多种方法将 \verb|while| 循环翻译成机器代码，GCC 在代码生成中使用其中的两种方法。

第一种翻译方法，称之为 jump to middle，它执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。如下所示：
\begin{cppcode}
  goto test;
loop:
  body-statement
test:
  t = test-expr;
  if (t)
    goto loop;
\end{cppcode}

第二种翻译方法，称之为 guarded-do，首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为 do-while 循环。当使用较高优化等级编译时，例如 -O1，GCC 会采用这种策略。如下所示：
\begin{cppcode}
t = test-expr;
if (!t)
  goto done;
loop:
  body-statement
  t = test-expr;
  if (t)
    goto loop;
done:
\end{cppcode}
利用这种策略，编译器常常可以优化初始的测试，例如认为测试条件总是满足。

\subsubsection{for 循环}

\verb|for| 语句的通用形式如下：
\begin{cppcode}
for (init-expr; test-expr; update-expr)
  body-statement
\end{cppcode}

GCC 为 \verb|for| 循环产生的代码是 \verb|while| 循环的两种翻译之一，这取决于优化的等级。jump to middle 策略会得到如下代码：
\begin{cppcode}
  init-expr;
  goto test;
loop:
  body-statement
  update-expr;
test:
  t = test-expr;
  if (t)
    goto loop;
\end{cppcode}
而 guarded-do 策略得到：
\begin{cppcode}
  init-expr;
  t = test-expr;
  if (!t)
    goto done;
loop:
  body-statement
  update-expr;
  t = test-expr;
  if (t)
    goto loop;
done:
\end{cppcode}

\subsection{switch 语句}

\verb|switch| 语句可以根据一个整数索引值进行 multiway branching。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了 C 代码的可读性，而且通过使用 jump table 这种数据结构使得实现更加高效。jump table 是一个数组，表项 i 是一个代码段的地址，这个代码段实现当 switch 索引值等于 i 时程序应该采取的动作。程序代码用 switch 索引值来执行一个 jump table 内的数组引用，确定跳转指令的目标。和使用一组很长的 \verb|if-else| 语句相比，使用 jump table 的优点是执行 switch 语句的时间与 switch 情况的数量无关。GCC 根据 switch 情况的数量和情况值的稀疏程度来翻译 switch 语句。当 switch 情况数量比较多，并且值的范围跨度比较小时，就会使用 jump table。

示例如下：
\begin{cppcode}
void switch_eg(long x, long n, long *dest) {
  long val = x;
  switch (n) {
    case 100:
      val *= 13;
      break;
    case 102:
      val += 10;
      // Fall through
    case 103:
      val += 11;
      break;
    case 104:
    case 106:
      val *= val;
      break;
    default:
      val = 0;
    }
  *dest = val;
}
\end{cppcode}
GNU 扩展支持了显示写出 jump table（创造了一个新的运算符 \verb|&&|，这个运算符创建一个指向代码位置的指针），上面的代码与下面的等价：
\begin{cppcode}
void switch_eg_impl(long x, long n, long *dest) {
  // Table of code pointers
  static void *jt[7] = {
    &&loc_A, &&loc_def, &&loc_B, &&loc_C, &&loc_D, &&loc_def, &&loc_D
  };
  unsigned long index = n - 100;
  long val;

  if (index > 6)
    goto loc_def;
  // Multiway branch
  goto *jt[index];

loc_A:
  val = x * 13;
  goto done;
loc_B:
  x = x + 10;
  // Fall through
loc_C:
  val = x + 11;
  goto done;
loc_D:
  val = x * x;
  goto done;
loc_def:
  val = 0;
done:
  *dest = val;
}
\end{cppcode}

使用 \verb|clang -Og -S| 编译如下：
\begin{gascode}
# void switch_eg(long x, long n, long *dest)
# x in %rdi, n in %rsi, dest in %rdx
switch_eg:
    xorl    %eax, %eax          # val = 0
    addq    $-100, %rsi         # Compute index = n - 100
    cmpq    $6, %rsi            # Compare index with 6
    ja      .LBB0_7             # if >, goto loc_def
    jmpq    *.LJTI0_0(,%rsi,8)  # Goto *jt[index]
.LBB0_5:                        # loc_D:
    imulq   %rdi, %rdi          # x = x * x
    jmp     .LBB0_6
.LBB0_2:                        # loc_A:
    leaq    (%rdi,%rdi,2), %rax # 3 * x
    leaq    (%rdi,%rax,4), %rax # 13 * x
    movq    %rax, (%rdx)        # dest = 13 * x
    retq                        # Return
.LBB0_3:                        # loc_B:
    addq    $10, %rdi           # x = x + 10
.LBB0_4:                        # loc_C:
    addq    $11, %rdi           # x = x + 11
.LBB0_6:
    movq    %rdi, %rax          # val = x
.LBB0_7:                        # done:
    movq    %rax, (%rdx)        # *dest = val
    retq                        # Return
\end{gascode}

在第 8 行的 \verb|jmpq| 指令的操作数有前缀 \verb|*|，表明这是一个间接跳转，索引由寄存器 \verb|%rsi| 给出。

在汇编代码中，跳转表用以下声明表示：
\begin{gascode}
    .section    .rodata,"a",@progbits
    .p2align    3       # Align address to multiple of 8
.LJTI0_0:
    .quad   .LBB0_2     # Case 100: loc_A
    .quad   .LBB0_7     # Case 101: loc_def
    .quad   .LBB0_3     # Case 102: loc_B
    .quad   .LBB0_4     # Case 103: loc_C
    .quad   .LBB0_5     # Case 104: loc_D
    .quad   .LBB0_7     # Case 105: loc_def
    .quad   .LBB0_5     # Case 106: loc_D
\end{gascode}
这些声明表明，在 \verb|.rodata|（只读数据）段，有一组 7 个 quad word，每个 quad word 都是与指定的汇编代码标号相关联的指令地址。

\section{过程}

过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：function、method、subroutine、handler 等，但是它们有一些共有的特性。

要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程 P 调用过程 Q，Q 执行后返回到 P。这些动作包括下面一个或多个机制：
\begin{itemize}
    \item 传递控制。在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。
    \item 传递数据。P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。
    \item 分配或释放内存。在开始时，Q 可能需要位局部变量分配内存空间，而在返回前，又必须释放这些存储空间。
\end{itemize}

x86-64 的过程实现包括一组特殊的指令和一些对机器资源使用的约定规则。

\subsection{运行时栈}

C 语言过程调用机制的一个关键特性在于使用了栈数据结构提供的后进先出的内存管理原则。在过程 P 调用过程 Q 的例子中，可以看到当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链中的过程，都是暂时被挂起的。当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当 Q 返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和寄存器存放着传递控制和数据、分配内存所需要的信息。当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

如前所述，x86-64 的栈向低地址方向增长，而栈指针 \verb|%rsp| 指向栈顶元素。可以用 \verb|pushq| 和 \verb|popq| 指令将数据存入栈中或是从栈中去除。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似的，可以通过增加栈指针来释放空间。

\endinput
