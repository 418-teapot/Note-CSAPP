\chapter{程序的机器级表示}

计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的管理，经过一系列的阶段生成机器代码。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

\section{历史观点}

Intel 处理器系列俗称 x86,经历了一个长期的、不断进化的发展过程。

8086 是第一代单芯片、16位微处理器；i386 将体系结构扩展到 32 位，增加了平坦寻址模式（flat addressing model）；Pentium III 引入了 SSE 指令；Pentium 4 扩展到了 SSE2；Pentium 4E 增加了超线程；Core i7 Nehalem 同时支持超线程和多核；Core i7 Sandy Bridge 引入了 AVX；Core i7 Haswell 扩展到了 AVX2。

\section{程序编码}

\subsection{机器级代码}

计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。第一种是 ISA 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA，包括 x86，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

在整个编译过程中，编译器会完成大部分的工作，将把 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。x86-64 的机器代码和原始的 C 代码差别很大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：

\begin{itemize}
    \item 程序计数器（PC，在 x86-64 中用 \verb|%rip| 来表示）给出要执行的下一条指令在内存中的地址。
    \item 整数寄存器堆（共 16 个寄存器），分别存储 64 位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
    \item 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息，通常用于控制流或者条件传送。
    \item 一组向量寄存器可以存放一个或多个整数或浮点数值。
\end{itemize}

\subsection{代码示例}

假设 C 语言代码文件 \verb|mstore.c|：

\begin{cppcode}
long mult2(long, long);

void multstore(long x, long y, long *dest) {
  long t = mult2(x, y);
  *dest = t;
}
\end{cppcode}

在命令行上使用 \verb|-S| 选项，就能看到产生的汇编代码：\verb|gcc -Og -S mstore.c| 或者 \verb|clang -Og -S mstore.c|。

汇编代码文件包含各种声明，包含下面几行：

\begin{gascode}
multstore:
    pushq   %rbx
    movq    %rdx, %rbx
    callq   mult2
    movq    %rax, (%rbx)
    popq    %rbx
    retq
\end{gascode}

如果使用 \verb|-c| 选项，会编译并汇编该代码：\verb|gcc -Og -c mstore.c| 或者 \verb|clang -Og -c mstore.c|。

这就会产生目标代码文件 \verb|mstore.o|，它是二进制格式的，所以无法直接查看。

\marginpar{\footnotesize 要展示程序（比如 mstore）的二进制目标代码，可以用反汇编器确定该过程的代码长度是 14 字节。然后，在文件 mstore.o 上运行调试工具 GDB，输入命令：x/14xb multstore。这条命令会让调试器显示从函数 multstore 所处地址开始的 14 个十六进制格式表示的字节。}

要查看机器代码文件的内容，有一类称为反汇编器（disassembler）的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。\verb|objdump -d mstore.o| 或者\\ \verb|llvm-objdump -d mstore.o|。

结果如下：

\begin{textcode}
0000000000000000 multstore:
    0: 53                               pushq   %rbx
    1: 48 89 d3                         movq    %rdx, %rbx
    4: e8 00 00 00 00                   callq   0 <multstore+0x9>
    9: 48 89 03                         movq    %rax, (%rbx)
    c: 5b                               popq    %rbx
    d: c3                               retq
\end{textcode}

其中一些关于机器代码和它的反汇编表示的特性值得主义：

\begin{itemize}
    \item x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少额度指令所需的字节数少，而哪些不太常用或操作数较多的指令所需字节数较多。
    \item 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。
    \item 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它不需要访问该程序的源代码或者汇编代码。
    \item 反汇编器使用的指令命名规则可能与生成的汇编代码有一些细微的区别（常见于 objdump 和 GCC）。
\end{itemize}

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须包含有一个 \verb|main| 函数。假设有文件 \verb|main.c|：

\begin{cppcode}
#include <stdio.h>

void multstore(long, long, long *);

int main() {
  long d;
  multstore(2, 3, &d);
  printf("2 * 3 --> %ld\n", d);
  return 0;
}
long mult2(long a, long b) {
  long s = a * b;
  return s;
}
\end{cppcode}

然后，生成可执行文件 \verb|prog|：\verb|clang -Og -o prog main.c mstore.c|。文件 \verb|prog| 的体积变得很大，因为它不仅包含了两个函数的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。反汇编 \verb|prog| 文件：\verb|llvm-objdump -d prog|。

反汇编器会抽取出各种代码序列，包括下面这段：

\begin{textcode}
0000000000401170 multstore:
  401170: 53                            pushq   %rbx
  401171: 48 89 d3                      movq    %rdx, %rbx
  401174: e8 e7 ff ff ff                callq   -25 <mult2>
  401179: 48 89 03                      movq    %rax, (%rbx)
  40117c: 5b                            popq    %rbx
  40117d: c3                            retq
  40117e: 66 90                         nop
\end{textcode}

这段代码与 \verb|mstore.c| 反汇编产生的代码几乎完全一样。其中一个主要的区别是左边列出的地址不同（链接器将这段代码的地址移到了一段不同的地址范围中）。第二个不同之处在于链接器填上了 \verb|callq| 指令调用函数 \verb|mult2| 需要使用的地址。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是多了一条 \verb|nop| 指令，插入 \verb|nop| 的作用是为了使函数代码变为 16 字节，使得就存储器系统性能而言，能够更好地放置下一个代码块。

\subsection{关于格式的注解}

所有以 \verb|.| 开头的都是指导汇编器和链接器工作的伪指令。通常可以忽略。

\subsubsection{AT\&T 与 Intel 汇编代码格式}

我们的表述是 AT\&T 格式的汇编代码，这是 GCC、OBJDUMP 等工具的默认格式。微软的工具和 Intel 的文档，其汇编代码是 Intel 格式的。可以使用 \verb|clang -Og -S -masm=intel mstore.c| 产生 \verb|multstore| 函数的 Intel 格式的代码：

\begin{nasmcode}
multstore:
    push    rbx
    mov     rbx, rdx
    call    mult2@PLT
    mov     qword ptr [rbx], rax
    pop     rbx
    ret
\end{nasmcode}

可以看到 Intel 和 AT\&T 格式再如下方面有所不同：

\begin{itemize}
    \item Intel 格式省略了指示大小的后缀（push 而非 pushq）。
    \item Intel 格式省略了寄存器名字前面的 \verb|%| 号。
    \item Intel 格式用不同大方式来描述内存中的位置（\verb|qword ptr [rbx]| 而非 \verb|(%rbx)|）。
    \item 在带有多个操作数的指令情况下，列出操作数的顺序相反。
\end{itemize}

\section{数据格式}

由于 x86 是从 16 位体系结构扩展而来的，Intel 用术语字（word）表示 16 位数据类型，因此，称 32 位数为 double words 或 long word，称 64 位数为 quad words。AT\&T 格式的汇编代码指令大部分都有一个字符的后缀，表明操作数的大小，如下表所示。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llcc}
        \toprule
        C declaration & Intel data type & Assembly-code suffix & Size(bytes) \\
        \midrule
        char    & Byte              & \verb|b|  & 1 \\
        short   & Word              & \verb|w|  & 2 \\
        int     & Double word       & \verb|l|  & 4 \\
        long    & Quad word         & \verb|q|  & 8 \\
        char *  & Quad word         & \verb|q|  & 8 \\
        float   & Single precision  & \verb|s|  & 4 \\
        double  & Double precision  & \verb|l|  & 8 \\
        \bottomrule
    \end{tabular}
\end{table}

注意，Double word 和 Double precision 使用同样的后缀 \verb|l|，这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

\section{访问信息}

一个 x86-64 的 CPU 包含一组 16 个 64 位值的通用寄存器，用来存储整数数据和指针，它们的名字都以 \verb|%r| 开头，最初的 8086 有 8 个 16 位的寄存器，即图中的 \verb|%ax| 到 \verb|%bp|。每个寄存器都有特殊的用途，它们的名字就反映了它们的用途。扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 \verb|%eax| 到 \verb|%ebp|。扩展到 x86-64 后，同样扩展成 64 位寄存器，标号从 \verb|%rax| 到 \verb|%rbp|。除此之外，还增加了 8 个新的寄存器，它们的标号时按照新的命名规则指定的，从 \verb|%r8| 到 \verb|%r15|。

\begin{figure}[!p]
    \centering
    \begin{tikzpicture}
        \foreach \r/\e/\w/\b/\t [count=\x] in {
            rax/eax/ax/al/Return value,
            rbx/ebx/bx/bl/Callee saved,
            rcx/ecx/cx/cl/4th argument,
            rdx/edx/dx/dl/3rd argument,
            rsi/esi/si/sil/2nd argumrnt,
            rdi/edi/di/dil/1st argument,
            rbp/ebp/bp/bpl/Callee saved,
            rsp/esp/sp/spl/Stack pointer,
            r8/r8d/r8w/r8b/5th argument,
            r9/r9d/r9w/r9b/6th argument,
            r10/r10d/r10w/r10b/Caller saved,
            r11/r11d/r11w/r11b/Caller saved,
            r12/r12d/r12w/r12b/Callee saved,
            r13/r13d/r13w/r13b/Callee saved,
            r14/r14d/r14w/r14b/Callee saved,
            r15/r15d/r15w/r15b/Callee saved
        } {
            \draw[fill=White!60!ProcessBlue] (0, -1.4 * \x + 0.5) rectangle (16, -1.4 * \x - 0.5);
            \draw[fill=White!90!ProcessBlue] ($(8, -1.4 * \x + 0.5) + (0, -2pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-2pt, 2pt)$);
            \draw[fill=White] ($(12, -1.4 * \x + 0.5) + (0, -4pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-4pt, 4pt)$);
            \draw[fill=White, thick] ($(14, -1.4 * \x + 0.5) + (0, -6pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-6pt, 6pt)$);
            \node[right] at (0, -1.4 * \x) {\texttt{\%\r}};
            \node[right] at (8, -1.4 * \x) {\texttt{\%\e}};
            \node[right] at (12, -1.4 * \x) {\texttt{\%\w}};
            \node[right] at (14, -1.4 * \x) {\texttt{\%\b}};
            \node[right] at (16, -1.4 * \x) {\t};
        }
        \node[above] at (0, -0.5) {63};
        \node[above] at (8, -0.5) {31};
        \node[above] at (12, -0.5) {15};
        \node[above] at (14, -0.5) {7};
        \node[above] at (16, -0.5) {0};
    \end{tikzpicture}
\end{figure}

\subsection{操作数指示符}

大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64 支持多种操作格式。第一种类型是立即数（immediate），用来表示常数值。在 AT\&T 格式的汇编代码中，立即数的书写方式是 \$ 后面跟一个用标准 C 表示法表示的整数。第二种类型是寄存器（register），表示某个寄存器的内容。我们用符号 $r_a$ 来表示任意寄存器 $a$，用引用 $R[r_a]$ 来表示它的值。第三种操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。我们用符号 $M_b[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始的 $b$ 个字节值的引用。为了简便，通常省去下标 $b$。

如下表所示，x86-64 还支持多种寻址模式。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        Type & Form & Operand value & Name \\
        \midrule
        Immediate & \$$Imm$ & $Imm$ & Immediate \\
        \\
        Register & $r_a$ & $R[r_a]$ & Register \\
        \\
        Memory & $Imm$              & $M[Imm]$                              & Absolute \\
        Memory & $(r_a)$            & $M[R[r_a]]$                           & Indirect \\
        Memory & $Imm(r_b)$         & $M[Imm + R[r_b]]$                     & Base + displacement \\
        Memory & $(r_b, r_i)$       & $M[R[r_b] + R[r_i]]$                  & Indexed \\
        Memory & $Imm(r_b, r_i)$    & $M[Imm + R[r_b] + R[r_i]]$            & Indexed \\
        Memory & $(, r_i, s)$       & $M[R[r_i] \cdot s]$                   & Scaled indexed \\
        Memory & $Imm(, r_i, s)$    & $M[Imm + R[r_i] \cdot s]$             & Scaled indexed \\
        Memory & $(r_b, r_i, s)$    & $M[R[r_b] + R[r_i] \cdot s]$          & Scaled indexed \\
        Memory & $Imm(r_b, r_i, s)$ & $M[Imm + R[r_b] + R[r_i] \cdot s]$    & Scaled indexed \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{数据传送指令}

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

MOV 类指令将数据从原位置复制到目的位置，不做任何变化。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        MOV                & $S, D$ & $D \leftarrow S$  & Move \\
        \quad\texttt{movb} &        &                   & Move byte \\
        \quad\texttt{movw} &        &                   & Move word \\
        \quad\texttt{movl} &        &                   & Move double word \\
        \quad\texttt{movq} &        &                   & Move quad word \\
        \texttt{movabsq}   & $I, R$ & $R \leftarrow I$  & Move absolute word \\
        \bottomrule
    \end{tabular}
\end{table}

\marginpar{\footnotesize 造成这个例外的原因是 x86-64 采用的惯例，即任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分设置为 0。}

源操作数可以是立即数、寄存器或者内存中的值，目的操作数可以是寄存器或者是内存地址。x86-64 限制 传送指令的两个操作数不能同时指向内存。大多数情况下，MOV 指令只会更新目的操作数指定的寄存器字节或者内存位置。唯一的例外是 \verb|movl| 指令以寄存器作为目的时。它会把该寄存器的高 4 字节设置为 0。

MOVZ 类指令把目的中剩余的字节填充为 0,而 MOVS 类指令填充为符号位。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        Instruction & Effect & Description \\
        \midrule
        MOVZ \quad $S, R$ & $R \leftarrow ZeroExtend(S)$ & Move with zero extension \\
        \quad\texttt{movzbw} & & Move zero-extended byte to word \\
        \quad\texttt{movzbl} & & Move zero-extended byte to double word \\
        \quad\texttt{movzwl} & & Move zero-extended word to doubel word \\
        \quad\texttt{movzbq} & & Move zero-extended byte to quad word \\
        \quad\texttt{movzwq} & & Move zero-extended word to quad word \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        Instruction & Effect & Description \\
        \midrule
        MOVS \quad $S, R$ & $R \leftarrow SignExtend(S)$ & Move with sign extension \\
        \quad\texttt{movsbw} & & Move sign-extended byte to word \\
        \quad\texttt{movsbl} & & Move sign-extended byte to double word \\
        \quad\texttt{movswl} & & Move sign-extended word to double word \\
        \quad\texttt{movsbq} & & Move sign-extended byte to quad word \\
        \quad\texttt{movswq} & & Move sign-extended word to quad word \\
        \quad\texttt{movslq} & & Move sign-extended double to quad word \\
        \texttt{cltq} & $\texttt{\%rax} \leftarrow SignExtend(\texttt{\%eax})$ & Sign-extend \texttt{\%eax} to \texttt{\%rax} \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{数据传送示例}

略。

\subsection{压入和弹出栈数据}

栈是一种数据结构，可以添加或者删除值，遵循后进先出的原则。通过 push 操作把数据压入栈中，通过 pop 操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一段插入和删除元素。这一端被称为栈顶。x86-64 中，程序栈存放在内存中某个区域。栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址最低的。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{pushq} & $S$ & $R[\texttt{\%rsp}] \leftarrow R[\texttt{\%rsp}] - 8$; & Push quad word \\
        & & $M[R[\texttt{\%rsp}]] \leftarrow S$ & \\
        \texttt{popq} & $D$ & $D \leftarrow M[R[\texttt{\%rsp}]]$; & Pop quad word \\
        & & $R[\texttt{\%rsp}] \leftarrow R[\texttt{\%rsp}] + 8$ & \\
        \bottomrule
    \end{tabular}
\end{table}

\verb|pushq| 指令的功能是把数据压入到栈上，而 \verb|popq| 指令是弹出数据，这两条指令都只有一个操作数。

\section{算术和逻辑操作}

下表列出了 x86-64 的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有四种带不同大小操作数的变种。\marginpar{\footnotesize 只有 \texttt{leaq} 没有其他大小的变种。}这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{leaq} & $S, D$ & $D \leftarrow \&S$ & Load effective address \\
        \\
        INC  & $D$    & $D \leftarrow D + 1$    & Increment \\
        DEC  & $D$    & $D \leftarrow D - 1$    & Decrement \\
        NEG  & $D$    & $D \leftarrow -D$       & Negate \\
        NOT  & $D$    & $D \leftarrow \~{}D$    & Complement \\
        \\
        ADD  & $S, D$ & $D \leftarrow D + S$    & Add \\
        SUB  & $S, D$ & $D \leftarrow D - S$    & Subtract \\
        IMUL & $S, D$ & $D \leftarrow D * S$    & Multiply \\
        XOR  & $S, D$ & $D \leftarrow D \^{} S$ & Exclusive-or \\
        OR   & $S, D$ & $D \leftarrow D | S$    & Or \\
        AND  & $S, D$ & $D \leftarrow D \& S$   & And \\
        \\
        SAL  & $k, D$ & $D \leftarrow D << k$ & Left shift \\
        SHL  & $k, D$ & $D \leftarrow D << k$ & Left shift(same as SAL) \\
        SAR  & $k, D$ & $D \leftarrow D >>_A k$ & Arithmetic right shift \\
        SHR  & $k, D$ & $D \leftarrow D >>_L k$ & Logical right shift \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{加载有效地址}

load effective address 指令 \verb|leaq| 实际上是 \verb|movq| 指令的变形，该指令的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。另外，它还可以简洁地描述普通的算术操作。编译器经常利用 \verb|leaq| 的一些灵活用法，根本就与有效地址计算无关。例如：

\begin{cppcode}
long scale(long x, long y, long z) {
  long t = x + 4 * y + 12 * z;
  return t;
}
\end{cppcode}

编译时，该函数的算术运算以三条 \verb|leaq| 指令实现：

\begin{gascode}
# long scale(long x, long y, long z)
# x in %rdi, y in %rsi, z in %rdx
scale:
    leaq    (%rdi,%rsi,4), %rax     # x + 4*y
    leaq    (%rdx,%rdx,2), %rcx     # z + 2*z = 3*z
    leaq    (%rax,%rcx,4), %rax     # (x+4*y) + 4*(3*z) = x + 4*y + 12*z
    retq
\end{gascode}

\subsection{一元和二元操作}

一元操作只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。二元操作有两个操作数，其中第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或者内存位置，第二个操作数可以是寄存器或者内存位置。

\subsection{移位操作}

移位操作的第一个操作数是移位量，第二个操作数是要移位的数。移位量可以是一个立即数，或者放在单字节寄存器 \verb|%cl| 中。

\subsection{讨论}

大多数指令，既可以用于无符号运算，又可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算可以实现有符号整数运算。

\subsection{特殊的算术运算}

2 个 64 位有符号或者无符号整数相乘得到的乘积需要 128 位来表示，x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。Intel 把 16 字节的数称为 oct word。下表展示了产生 128 位数的指令：

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{imulq} & $S$ & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow S \times R[\texttt{\%rax}]$ & Signed full multiply \\
        \texttt{mulq} & $S$ & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow S \times R[\texttt{\%rax}]$ & Unsigned full multiply \\
        \\
        \texttt{cqto} & & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow SignExtend(R[\texttt{\%rax}])$ & Convert to oct word \\
        \\
        \texttt{idivq} & $S$ & $R[\texttt{\%rdx}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \bmod S$; & Signed divide \\
        & & $R[\texttt{\%rax}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \div S$ & \\
        \texttt{divq} & $S$ & $R[\texttt{\%rdx}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \bmod S$; & Unsigned divide \\
        & & $R[\texttt{\%rax}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \div S$ & \\
        \bottomrule
    \end{tabular}
\end{table}

\verb|imulq| 指令有两种不同的形式。其中一种，是 IMUL 指令类中的一种。这种形式的 \verb|imulq| 指令是一个双操作数乘法指令，它从两个 64 位操作数产生一个 64 位乘积。

此外，x86-64 还提供了两条单操作数乘法指令，以计算两个 64 位数的全 128 位乘积，都要求一个参数必须在寄存器 \verb|%rax| 中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器 \verb|%rdx|（高 64 位）和 \verb|%rax|（低 64 位）中。

前面的算术运算表没有列出除法或取模操作。这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。

\section{控制}

\subsection{条件码}

除了整数寄存器，x86-64 CPU 还维护着一组单个位的条件码（condition code）寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：
\begin{itemize}
    \item \verb|CF|: Carry flag 最近的操作使最高位产生了进位。
    \item \verb|ZF|: Zero flag 最近的操作得出的结果为 0。
    \item \verb|SF|: Sign flag 最近的操作得出的结果为负数。
    \item \verb|OF|: Overflow flag 最近的操作导致一个补码溢出。
\end{itemize}

\verb|leaq| 指令不会改变任何条件码，除此之外，所有运算指令都会设置条件码。还有两类指令只设置条件码而不改变任何其他寄存器：CMP 指令根据两个操作数之差设置条件码，TEST 指令根据两个操作数的与设置条件码。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Based on & Description \\
        \midrule
        CMP & $S1, S2$ & $S2 - S1$ & Compare \\
        \quad\texttt{cmpb} & & & Compare byte \\
        \quad\texttt{cmpw} & & & Compare word \\
        \quad\texttt{cmpl} & & & Compare double word \\
        \quad\texttt{cmpq} & & & Compare quad word \\
        TEST & $S1, S2$ & $S1 \& S2$ & Test \\
        \quad\texttt{testb} & & & Test byte \\
        \quad\texttt{testw} & & & Test word \\
        \quad\texttt{testl} & & & Test double word \\
        \quad\texttt{testq} & & & Test quad word \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{访问条件码}

条件码通常不会直接读取，常用的使用方法有三种：1）根据条件码的某种组合，将一个字节设置为 0 或者 1；2）条件跳转到程序的其他位置；3）条件传送数据。

对于第一种情况，该类指令称为 SET 指令，一条 SET 指令的目的操作数是低位单字节寄存器或者单字节的内存位置。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lllll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Synonym & Effect & Set Condition \\
        \midrule
        \texttt{sete}  & $D$ & \texttt{setz}  & $D \leftarrow ZF$     & Equal / zero \\
        \texttt{setne} & $D$ & \texttt{setnz} & $D \leftarrow \~{}ZF$ & Not equal / not zero \\
        \\
        \texttt{sets}  & $D$ & & $D \leftarrow SF$     & Negative \\
        \texttt{setns} & $D$ & & $D \leftarrow \~{}SF$ & Nonnegative \\
        \\
        \texttt{setg}  & $D$ & \texttt{setnle} & $D \leftarrow \~{}(SF\^{}OF)\&\~{}ZF$ & Greater (signed >) \\
        \texttt{setge} & $D$ & \texttt{setnl}  & $D \leftarrow \~{}(SF\^{}OF)$         & Greater or equal(signed >=) \\
        \texttt{setl}  & $D$ & \texttt{setnge} & $D \leftarrow SF\^{}OF$               & Less (signed <) \\
        \texttt{setle} & $D$ & \texttt{setng}  & $D \leftarrow (SF\^{}OF)|ZF$          & Less or equal (signed <=) \\
        \\
        \texttt{seta}  & $D$ & \texttt{setnbe} & $D \leftarrow \~{}CF\&\~{}ZF$ & Above (unsigned >) \\
        \texttt{setae} & $D$ & \texttt{setnb}  & $D \leftarrow \~{}CF$         & Above or equal (unsigned >=) \\
        \texttt{setb}  & $D$ & \texttt{setnae} & $D \leftarrow CF$             & Below (unsigned <) \\
        \texttt{setbe} & $D$ & \texttt{setna}  & $D \leftarrow CF|ZF$          & Below or equal (unsigned <=) \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{跳转指令}

jump 指令会让程序在执行时切换到一个全新的位置，在汇编代码中，这些跳转的目的地通常用一个 label 指明。下表列出了不同的跳转指令。\verb|jmp| 指令是无条件跳转，可以是直接跳转，也可以是间接跳转。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lllll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Synonym & Jump condition & Description \\
        \midrule
        \texttt{jmp} & $Label$ & & 1 & Direct jump \\
        \texttt{jmp} & $*Operand$ & & 1 & Indirect jump \\
        \texttt{je}  & $Label$ & \texttt{jz}  & $ZF$ & Equal / zero \\
        \texttt{jne} & $Label$ & \texttt{jnz} & $\~{}ZF$ & Not equal / not zero \\
        \texttt{js}  & $Label$ &              & $SF$ & Negative \\
        \texttt{jns} & $Label$ &              & $\~{}SF$ & Nonnegative \\
        \texttt{jg}  & $Label$ & \texttt{jnle} & $\~{}(SF\^{}OF)\&\~{}ZF$ & Greater (signed >) \\
        \texttt{jge} & $Label$ & \texttt{jnl}  & $\~{}(SF\^{}OF)$         & Greater or equal (signed >=) \\
        \texttt{jl}  & $Label$ & \texttt{jnge} & $SF\^{}OF$               & Less (signed <) \\
        \texttt{jle} & $Label$ & \texttt{jng}  & $(SF\^{}OF)|ZF$          & Less or equal (signed <=) \\
        \texttt{ja}  & $Label$ & \texttt{jnbe} & $\~{}CF\&\~{}ZF$         & Above (unsigned >) \\
        \texttt{jae} & $Label$ & \texttt{jnb}  & $\~{}CF$                 & Above or equal (unsigned >=) \\
        \texttt{jb}  & $Label$ & \texttt{jnae} & $CF$                     & Below (unsigned <) \\
        \texttt{jbe} & $Label$ & \texttt{jna}  & $CF|ZF$                  & Below or equal (unsigned <=) \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{跳转指令的编码}

在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码，跳转地址由 PC-relative 和绝对地址两种。

当执行 PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。这种管理可以追溯到早期的实现，当时的处理器会将更新程序计数器作为执行一条指令的第一步。

PC 相对寻址的好处：指令编码简洁，方便重定位，目标代码可以不做改变就能移动到内存中不同的位置。

\subsection{用条件控制来实现条件分支}

将条件表达式和语句从 C 语言翻译成机器语言，最常用的方式是结合有条件和无条件跳转。

C 语言中的 \verb|if-else| 语句的通用形式模板如下：

\begin{cppcode}
if (test-expr)
  then-statement
else
  else-statement
\end{cppcode}

这里的 \verb|test-expr| 是一个整数表达式，它的取值为 0 或者非 0。两个分支语句中只会执行一个。

对于这种通用形式，汇编实现通常会使用下面这种形式，这里，我们用 C 语法来描述控制流：

\begin{cppcode}
  t = test-expr;
  if (!t)
    goto done;
false:
  else-statement
done:
\end{cppcode}

也就是，汇编器为 \verb|then-statement| 和 \verb|else-statement| 产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。

\subsection{用条件传送来实现条件分支}

实现条件操作的传统方法是通过使用控制的条件转移。一种替代的策略是使用数据额条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选择一个。

下表列出了 x86-64 上一些可用的条件传送指令，源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lllll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Synonym & Move condition & Description \\
        \midrule
        \texttt{cmove}  & $S, R$ & \texttt{cmovz}   & $ZF$ & Equal / zero \\
        \texttt{cmovne} & $S, R$ & \texttt{cmovnz}  & $\~{}ZF$ & Not equal / not zero \\
        \texttt{cmovs}  & $S, R$ &                  & $SF$ & Negative \\
        \texttt{cmovns} & $S, R$ &                  & $\~{}SF$ & Nonnegative \\
        \texttt{cmovg}  & $S, R$ & \texttt{cmovnle} & $\~{}(SF\^{}OF)\&\~{}ZF$ & Greater (signed >) \\
        \texttt{cmovge} & $S, R$ & \texttt{cmovnl}  & $\~{}(SF\^{}OF)$         & Greater or equal (signed >=) \\
        \texttt{cmovl}  & $S, R$ & \texttt{cmovnge} & $SF\^{}OF$               & Less (signed <) \\
        \texttt{cmovle} & $S, R$ & \texttt{cmovng}  & $(SF\^{}OF)|ZF$          & Less or equal (signed <=) \\
        \texttt{cmova}  & $S, R$ & \texttt{cmovnbe} & $\~{}CF\&\~{}ZF$         & Above (unsigned >) \\
        \texttt{cmovae} & $S, R$ & \texttt{cmovnb}  & $\~{}CF$                 & Above or equal (unsigned >=) \\
        \texttt{cmovb}  & $S, R$ & \texttt{cmovnae} & $CF$                     & Below (unsigned <) \\
        \texttt{cmovbe} & $S, R$ & \texttt{cmovna}  & $CF|ZF$                  & Below or equal (unsigned <=) \\
        \bottomrule
    \end{tabular}
\end{table}

考虑下面的条件表达式和赋值的通用形式：\cppinline{v = test-expr ? then-epxr : else-expr;}

用条件控制转移的标准方法来编译这个表达式会得到如下形式：

\begin{cppcode}
  if (!text-expr)
    goto false;
  v = then-expr;
  goto done;
false:
  v = else-expr;
done:
\end{cppcode}

基于条件传送的代码，会对 \verb|then-expr| 和 \verb|else-expr| 都求值，最终值的选择基于对 \verb|test-expr| 的求值。可以用下面的抽象代码描述：
\begin{cppcode}
v = then-expr;
ve = else-expr;
t = test-expr;
if (!t) v = ve;
\end{cppcode}
这个序列的最后一条语句是用条件传送指令实现的。

不是所有的条件表达式都可以用条件传送来编译。最重要的是，无论测试结果如何，我们给出的抽象代码会对 \verb|then-expr| 和 \verb|else-epxr| 都求值。如果这两个表达式中的任意一个产生错误或者副作用，就会导致未预期的行为。

\subsection{循环}

C 语言提供了多种循环结构，即 \verb|do-while|、\verb|while| 和 \verb|for|。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。

\subsubsection{do-while 循环}

\verb|do-while| 语句的通用形式如下：
\begin{cppcode}
do
  body-statement
  while (test-expr);
\end{cppcode}
这个循环的效果就是重复执行 \verb|body-statement|，对 \verb|test-expr| 求值，如果求值的结果为非 0，就继续循环。可以看到，\verb|body-statement| 至少会执行一次。

这种通用形式可以被翻译成如下所示的条件和 \verb|goto| 语句：
\begin{cppcode}
loop:
  body-statement
  t = test-expr;
  if (t)
    goto loop;
\end{cppcode}

\subsubsection{while 循环}

\verb|while| 语句的通用形式如下：
\begin{cppcode}
while (test-expr)
  body-statement
\end{cppcode}
与 \verb|do-while| 的不同之处在于，在第一次执行 \verb|body-statement| 之前，它会对 \verb|test-expr| 求值，循环有可能在执行之前就中止了。有很多种方法将 \verb|while| 循环翻译成机器代码，GCC 在代码生成中使用其中的两种方法。

第一种翻译方法，称之为 jump to middle，它执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。如下所示：
\begin{cppcode}
  goto test;
loop:
  body-statement
test:
  t = test-expr;
  if (t)
    goto loop;
\end{cppcode}

第二种翻译方法，称之为 guarded-do，首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为 do-while 循环。当使用较高优化等级编译时，例如 -O1，GCC 会采用这种策略。如下所示：
\begin{cppcode}
t = test-expr;
if (!t)
  goto done;
loop:
  body-statement
  t = test-expr;
  if (t)
    goto loop;
done:
\end{cppcode}
利用这种策略，编译器常常可以优化初始的测试，例如认为测试条件总是满足。

\subsubsection{for 循环}

\verb|for| 语句的通用形式如下：
\begin{cppcode}
for (init-expr; test-expr; update-expr)
  body-statement
\end{cppcode}

GCC 为 \verb|for| 循环产生的代码是 \verb|while| 循环的两种翻译之一，这取决于优化的等级。jump to middle 策略会得到如下代码：
\begin{cppcode}
  init-expr;
  goto test;
loop:
  body-statement
  update-expr;
test:
  t = test-expr;
  if (t)
    goto loop;
\end{cppcode}
而 guarded-do 策略得到：
\begin{cppcode}
  init-expr;
  t = test-expr;
  if (!t)
    goto done;
loop:
  body-statement
  update-expr;
  t = test-expr;
  if (t)
    goto loop;
done:
\end{cppcode}

\subsection{switch 语句}

\verb|switch| 语句可以根据一个整数索引值进行 multiway branching。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了 C 代码的可读性，而且通过使用 jump table 这种数据结构使得实现更加高效。jump table 是一个数组，表项 i 是一个代码段的地址，这个代码段实现当 switch 索引值等于 i 时程序应该采取的动作。程序代码用 switch 索引值来执行一个 jump table 内的数组引用，确定跳转指令的目标。和使用一组很长的 \verb|if-else| 语句相比，使用 jump table 的优点是执行 switch 语句的时间与 switch 情况的数量无关。GCC 根据 switch 情况的数量和情况值的稀疏程度来翻译 switch 语句。当 switch 情况数量比较多，并且值的范围跨度比较小时，就会使用 jump table。

示例如下：
\begin{cppcode}
void switch_eg(long x, long n, long *dest) {
  long val = x;
  switch (n) {
    case 100:
      val *= 13;
      break;
    case 102:
      val += 10;
      // Fall through
    case 103:
      val += 11;
      break;
    case 104:
    case 106:
      val *= val;
      break;
    default:
      val = 0;
    }
  *dest = val;
}
\end{cppcode}
GNU 扩展支持了显示写出 jump table（创造了一个新的运算符 \verb|&&|，这个运算符创建一个指向代码位置的指针），上面的代码与下面的等价：
\begin{cppcode}
void switch_eg_impl(long x, long n, long *dest) {
  // Table of code pointers
  static void *jt[7] = {
    &&loc_A, &&loc_def, &&loc_B, &&loc_C, &&loc_D, &&loc_def, &&loc_D
  };
  unsigned long index = n - 100;
  long val;

  if (index > 6)
    goto loc_def;
  // Multiway branch
  goto *jt[index];

loc_A:
  val = x * 13;
  goto done;
loc_B:
  x = x + 10;
  // Fall through
loc_C:
  val = x + 11;
  goto done;
loc_D:
  val = x * x;
  goto done;
loc_def:
  val = 0;
done:
  *dest = val;
}
\end{cppcode}

使用 \verb|clang -Og -S| 编译如下：
\begin{gascode}
# void switch_eg(long x, long n, long *dest)
# x in %rdi, n in %rsi, dest in %rdx
switch_eg:
    xorl    %eax, %eax          # val = 0
    addq    $-100, %rsi         # Compute index = n - 100
    cmpq    $6, %rsi            # Compare index with 6
    ja      .LBB0_7             # if >, goto loc_def
    jmpq    *.LJTI0_0(,%rsi,8)  # Goto *jt[index]
.LBB0_5:                        # loc_D:
    imulq   %rdi, %rdi          # x = x * x
    jmp     .LBB0_6
.LBB0_2:                        # loc_A:
    leaq    (%rdi,%rdi,2), %rax # 3 * x
    leaq    (%rdi,%rax,4), %rax # 13 * x
    movq    %rax, (%rdx)        # dest = 13 * x
    retq                        # Return
.LBB0_3:                        # loc_B:
    addq    $10, %rdi           # x = x + 10
.LBB0_4:                        # loc_C:
    addq    $11, %rdi           # x = x + 11
.LBB0_6:
    movq    %rdi, %rax          # val = x
.LBB0_7:                        # done:
    movq    %rax, (%rdx)        # *dest = val
    retq                        # Return
\end{gascode}

在第 8 行的 \verb|jmpq| 指令的操作数有前缀 \verb|*|，表明这是一个间接跳转，索引由寄存器 \verb|%rsi| 给出。

在汇编代码中，跳转表用以下声明表示：
\begin{gascode}
    .section    .rodata,"a",@progbits
    .p2align    3       # Align address to multiple of 8
.LJTI0_0:
    .quad   .LBB0_2     # Case 100: loc_A
    .quad   .LBB0_7     # Case 101: loc_def
    .quad   .LBB0_3     # Case 102: loc_B
    .quad   .LBB0_4     # Case 103: loc_C
    .quad   .LBB0_5     # Case 104: loc_D
    .quad   .LBB0_7     # Case 105: loc_def
    .quad   .LBB0_5     # Case 106: loc_D
\end{gascode}
这些声明表明，在 \verb|.rodata|（只读数据）段，有一组 7 个 quad word，每个 quad word 都是与指定的汇编代码标号相关联的指令地址。

\section{过程}

过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：function、method、subroutine、handler 等，但是它们有一些共有的特性。

要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程 P 调用过程 Q，Q 执行后返回到 P。这些动作包括下面一个或多个机制：
\begin{itemize}
    \item 传递控制。在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。
    \item 传递数据。P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。
    \item 分配或释放内存。在开始时，Q 可能需要位局部变量分配内存空间，而在返回前，又必须释放这些存储空间。
\end{itemize}

x86-64 的过程实现包括一组特殊的指令和一些对机器资源使用的约定规则。

\subsection{运行时栈}

C 语言过程调用机制的一个关键特性在于使用了栈数据结构提供的后进先出的内存管理原则。在过程 P 调用过程 Q 的例子中，可以看到当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链中的过程，都是暂时被挂起的。当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当 Q 返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和寄存器存放着传递控制和数据、分配内存所需要的信息。当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

如前所述，x86-64 的栈向低地址方向增长，而栈指针 \verb|%rsp| 指向栈顶元素。可以用 \verb|pushq| 和 \verb|popq| 指令将数据存入栈中或是从栈中去除。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似的，可以通过增加栈指针来释放空间。

当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧（stack fram）。下图给出了运行时栈的通用结构，包括把它划分为栈帧。当前正在执行的过程的帧总是在栈顶。当过程 P 调用过程 Q 时，会把返回地址压入栈中，指明当 Q 返回时，要从 P 程序的哪个位置继续执行。我们把这个返回地址当作 P 的栈帧的一部分，因为它存放的是与 P 相关的状态。Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧。通过寄存器，过程 P 可以传递最多 6 个整数值，但是如果 Q 需要更多的参数，P 可以在调用 Q 之前在自己的栈帧中存储好这些参数。

\begin{tikzfig}
    \coordinate (A) at (0, 0);
    \coordinate (B) at (4, 0);
    \coordinate (C) at (0, -15);
    \coordinate (D) at (B |- C);
    \coordinate (bd1) at ($(B)!1/3!(D)$);
    \coordinate (bd2) at ($(B)!2/3!(D)$);
    \foreach \i in {0, 1, 2, ..., 7} {
        \coordinate (e\i) at ($(bd1)!\i/7!(bd2)$);
    }
    \coordinate (f1) at ($(bd2)!1/3!(D)$);
    \coordinate (f2) at ($(bd2)!2/3!(D)$);
    \fill[fill=White!60!gray] (A) rectangle node[align=center, font=\LARGE\bfseries]{.\\.\\.} (bd1);
    \fill[fill=White!80!ProcessBlue] (e0 -| A) rectangle node[align=center, font=\bfseries]{.\\[-0.3ex].\\[-0.3ex].} (e2);
    \path (e2 -| A) rectangle node{Argument $n$} (e3);
    \fill[fill=White!80!ProcessBlue] (e3 -| A) rectangle node[align=center, font=\bfseries]{.\\[-0.3ex].\\[-0.3ex].} (e5);
    \path (e5 -| A) rectangle node{Argument $7$} (e6);
    \path (e6 -| A) rectangle node{Return Address} (e7);
    \path (bd2 -| A) rectangle node{Saved registers} (f1);
    \path (f1 -| A) rectangle node{Local variables} (f2);
    \path (f2 -| A) rectangle node{Argument build area} (D);
    \draw[thick] (A) -- (B) -- (D) -- (C) -- (A);
    \draw[thick] (bd1) -- (bd1 -| A);
    \draw[thick] (bd2) -- (bd2 -| A);
    \draw (e2) -- (e2 -| A);
    \draw (e3) -- (e3 -| A);
    \draw (e5) -- (e5 -| A);
    \draw (e6) -- (e6 -| A);
    \draw (f1) -- (f1 -| A);
    \draw (f2) -- (f2 -| A);
    \path (A) -- node[above]{Stack ``bottom''} (B);
    \path (C) -- node[below]{Stack ``top''} (D);
    \draw[-latex] ($(C) + (-1, 0)$) node[left, align=right]{Stack pointer\\ \texttt{\%rsp}} -- (C);
    \draw[-latex] ($(bd2-|A) + (-2, 0)$) -- node[align=center, fill=white]{Increasing\\address} ($(bd1-|A) + (-2, 0)$);
    \draw[decorate, decoration={brace, raise=5pt}] (B) -- node[right, xshift=6pt]{Earlier frames} (bd1);
    \draw[decorate, decoration={brace, raise=5pt}] (bd1) -- node[right, xshift=6pt, align=left]{Frame for calling\\function P} (bd2);
    \draw[decorate, decoration={brace, raise=5pt}] (bd2) -- node[right, xshift=6pt, align=left]{Frame for executing\\function Q} (D);
\end{tikzfig}

为了提高空间和时间效率，x86-64 过程只分配自己需要的栈帧部分。当所有的局部变量都可以保存在寄存器，而且该函数不会调用任何其他函数时，可以不需要栈帧。

\subsection{转移控制}

将控制从函数 P 转移到函数 Q 只需要简单地把程序计数器设置为 Q 的代码的起始位置。当稍后从 Q 返回的时候，处理器必须记录好它需要继续执行 P 时的代码位置。在 x86-64 机器上，这个信息是用指令 \verb|call Q| 调用过程 Q 来记录的。该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址，是紧跟在 \verb|call| 指令后面的那条指令的地址。对应的指令 \verb|ret| 会从栈中弹出地址 A，并把 PC 设置为 A。

下表为 \verb|call| 和 \verb|ret| 指令的一般形式：
\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Description \\
        \midrule
        \texttt{call} & $Label$    & Procedure call \\
        \texttt{call} & $*Operand$ & Procedure call \\
        \texttt{ret}  &            & Return from call \\
        \bottomrule
    \end{tabular}
\end{table}

\verb|call| 指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是 * 后面跟一个操作数指示符。

\subsection{数据传送}

当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能把数据作为参数传递，而在过程返回还有可能包括返回一个值。x86-64 中，大部分过程间的数据传送是通过寄存器实现的。当过程 P 调用过程 Q 时，P 的代码必须首先把参数复制到适当的寄存器中。类似的，当 Q 返回到 P 时，P 的代码可以访问寄存器 \verb|%rax| 中的返回值。

x86-64 中，可以通过寄存器传递最多 6 个整型参数，如下表所示：
\begin{table}[!ht]
    \centering
    \begin{tabular}{ccccccc}
        \toprule
        \multirow{2}{*}{\begin{tabular}{c}Operand \\ size(bits)\end{tabular}} & \multicolumn{6}{c}{Argument number} \\
        \cmidrule{2-7}
        & 1 & 2 & 3 & 4 & 5 & 6 \\
        \midrule
        64 & \texttt{\%rdi} & \texttt{\%rsi} & \texttt{\%rdx} & \texttt{\%rcx} & \texttt{\%r8}  & \texttt{\%r9} \\
        32 & \texttt{\%edi} & \texttt{\%esi} & \texttt{\%edx} & \texttt{\%ecx} & \texttt{\%r8d} & \texttt{\%r9d} \\
        16 & \texttt{\%di}  & \texttt{\%si}  & \texttt{\%dx}  & \texttt{\%cx}  & \texttt{\%r8w} & \texttt{\%r9w} \\
        8  & \texttt{\%dil} & \texttt{\%sil} & \texttt{\%dxl} & \texttt{\%cxl} & \texttt{\%r8b} & \texttt{\%r9b} \\
        \bottomrule
    \end{tabular}
\end{table}

如果有一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。假设过程 P 调用过程 Q，有 $n$ 个整型参数，且 $n > 6$。那么 P 的代码分配的栈帧必须要能容纳 7 到 n 号参数的存储空间。要把参数 $1 \sim 6$ 复制到对应的寄存器，把参数 $7 \sim n$ 放到栈上，而参数 7 位于栈顶。通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。参数到位以后，程序就可以执行 \verb|call| 指令将控制转移到过程 Q 了。过程 Q 可以通过寄存器访问参数，有必要的话也可以通过栈访问。

\subsection{栈上的局部存储}

有些时候，局部数据必须存放在内存中哦你通过，常见的情况包括：
\begin{itemize}
    \item 寄存器不够存放所有的本地数据。
    \item 对一个局部变量使用地址运算符 \&，因此必须能够为它产生一个地址。
    \item 某些局部变量是数组或者结构体，因此必须能够通过数组或结构体引用被访问到。
\end{itemize}

\subsection{寄存器中的局部存储空间}

寄存器堆是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们人敢必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会负高调用者稍后会使用的寄存器。为此，x86-64 采用了一组统一的寄存器使用管理，所有的过程都必须遵循。

根据管理，寄存器 \verb|%rbx|、\verb|%rbp| 和 \verb|%r12|\~{}\verb|%r15| 被划分为被调用者保存寄存器。当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。有了这条惯例，P 的代码就能安全地把值存在被调用者保存寄存器中，调用 Q，然后继续使用寄存器中的值，不用担心值被破坏。

所有其他的寄存器，除了栈指针 \verb|%rsp|，都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。过程 P 在某个此类寄存器中有局部数据，然后调用过程 Q。因为 Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P（调用者）的责任。

\subsection{递归过程}

前面已经描述的寄存器和栈的惯例使得 x86-64 过程能够递归地调用自身。每个过程调用在栈中都有自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。

\section{数组分配和访问}

C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。C 语言的一个特点是可以产生指向数组元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址运算。

\subsection{基本原则}

对于数据类型 T 和整型常数 N，声明：\verb|T A[N];| \\ 起始位置表示为 $x_A$。这个声明有两个效果：首先，它在内存中分配一个 $L \cdot N$ 字节的连续区域，这里 L 是数据类型 T 的大小（单位为字节）。其次，它引入了标识符 \verb|A|，可以用 \verb|A| 来作为指向数组开头的指针，这个指针的值就是 $x_A$。可以用 $0 \sim N-1$ 的整数索引来访问该数组元素。数组元素 $i$ 会被存放在地址为 $x_A + L \cdot i$ 的地方。

\subsection{指针运算}

C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p 是一个指向类型为 T 的数据的指针，p 的值为 $x_p$，那么表达式 \verb|p+i| 的值为 $x_p + L \cdot i$，这里 L 是数据类型 T 的大小。

单操作数操作符 \verb|&| 和 \verb|*| 可以产生指针的间接引用指针。也就是，对于一个表示某个对象的表达式 \verb|Expr|， \verb|&Expr| 是给出该对象地址的一个指针。对于一个表示地址的表达式 \verb|AExpr|，\verb|*AExpr| 给出该地址处的值。因此，表达式 \verb|Expr| 和 \verb|*&Expr| 是等价的。可以对数组和指针应用数组下标操作。数组引用 \verb|A[i]| 等同于表达式 \verb|*(A+i)|。它计算第 i 个数组元素的地址，然后访问这个内存位置。

假设整型数组 E 的起始地址和整数索引 i 分别存放在寄存器 \verb|%rdx| 和 \verb|%rcx| 中，下表是一些与 E 有关的表达式：
\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        Expression & Type & Value & Assembly code \\
        \midrule
        \texttt{E}        & \texttt{int *} & $x_E$              & \texttt{movl \%rdx, \%rax} \\
        \texttt{E[0]}     & \texttt{int}   & $M[x_E]$           & \texttt{movl (\%rdx), \%eax} \\
        \texttt{E[i]}     & \texttt{int}   & $M[x_E + 4i]$      & \texttt{movl (\%rdx, \%rcx, 4), \%eax} \\
        \texttt{\&E[2]}   & \texttt{int *} & $x_E + 8$          & \texttt{leaq 8(\%rdx), \%rax} \\
        \texttt{E+i-1}    & \texttt{int *} & $x_E + 4i - 12$    & \texttt{leaq -4(\%rdx, \%rcx, 4), \%rax} \\
        \texttt{*(E+i-3)} & \texttt{int}   & $M[x_E + 4i - 12]$ & \texttt{movl -12(\%rdx, \%rcx, 4), \%eax} \\
        \texttt{\&E[i]-E} & \texttt{long}  & $i$                & \texttt{movq \%rcx, \%rax} \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{嵌套的数组}

要访问多维数组的元素，编译器会以数组起始为基地址，偏移量为索引，产生计算期望的元素的偏移量，然后使用某种 MOV 指令。通常来说，对于一个声明为 \verb|T D[R][C};| 的数组，它的数组元素 \verb|D[i][j]| 的内存地址为：
\begin{equation}
    \&D[i][j] = x_D + L(C \cdot i + j)
    \label{def:2darray_addr}
\end{equation}

\subsection{定长数组}

C 语言编译器能够优化定长多维数组上的操作。这里我们展示优化等级设置为 \verb|-O1| 时 GCC 和 clang 采用的一些优化。假设将 \verb|fix_matrix| 声明为 $16 \times 16$ 的整型数组：
\begin{cppcode}
#define N 16
typedef int fix_matrix[N][N];
\end{cppcode}

原始的 C 代码如下：
\begin{cppcode*}{firstnumber=last}
// Compute i, k of fixed matrix product
int fix_prod_ele(fix_matrix A, fix_matrix B, long i, long k) {
  long j;
  int result = 0;

  for (j = 0; j < N; j++)
    result += A[i][j] * B[j][k];

  return result;
}
\end{cppcode*}

使用 \verb|gcc -O1| 生成的如下：
\begin{gascode}
fix_prod_ele:
.LFB0:
    salq    $6, %rdx            # 64 * i
    addq    %rdx, %rdi          # Aptr = &A[i][0]
    leaq    (%rsi,%rcx,4), %rax # Bptr = &B[0][k]
    leaq    1024(%rax), %rsi    # Bend = &B[N][k]
    movl    $0, %ecx            # result = 0
.L2:
    movl    (%rdi), %edx        # read *Aptr
    imull   (%rax), %edx        # (*Aptr) * (*Bptr)
    addl    %edx, %ecx          # add to result
    addq    $4, %rdi            # Aptr++
    addq    $64, %rax           # Bptr += N
    cmpq    %rsi, %rax          # compare Bptr with Bend
    jne     .L2                 # if !=, goto loop
    movl    %ecx, %eax
    ret                         # return
\end{gascode}

使用 \verb|clang -O1| 生成的如下：
\begin{gascode}
fix_prod_ele:
    shlq    $6, %rdx            # 64 * i
    addq    %rdi, %rdx          # Aptr = &A[i][0]
    leaq    (%rsi,%rcx,4), %rcx # Bptr = &B[0][k]
    xorl    %eax, %eax          # result = 0
    xorl    %esi, %esi          # j = 0
.LBB0_1:
    movl    (%rcx), %edi        # Read *Bptr
    imull   (%rdx,%rsi,4), %edi # *(Aptr + j) * (*Bptr)
    addl    %edi, %eax          # add to result
    addq    $1, %rsi            # j++
    addq    $64, %rcx           # Bptr += 64
    cmpq    $16, %rsi           # compare j with 16
    jne     .LBB0_1             # if !=, goto loop
    retq                        # return
\end{gascode}

可以看到，编译器聪明地认识到数组的长度，并把数组引用转换成了指针间接引用。

\subsection{变长数组}

C99 中引入了一种功能，允许数组的长度是表达式，在数组被分配的时候才计算出来。可以将一个数组声明为：\verb|int A[expr1][expr2]|。它可以作为一个局部变量，也可以作为一个函数的参数，然后在遇到这个声明的时候，通过对表达式 \verb|expr1| 和 \verb|expr2| 求值来确定数组的维度。

例如：
\begin{cppcode}
int var_ele(long n, int A[n][n], long i, long j) {
  return A[i][j];
}
\end{cppcode}
\verb|clang -Og -S|：
\begin{gascode}
var_ele:
    imulq   %rdx, %rdi              # n * i
    leaq    (%rsi,%rdi,4), %rax     # Aptr + 4ni
    movl    (%rax,%rcx,4), %eax     # Read from M[Aptr+4ni]
    retq
\end{gascode}

\section{异质的数据结构}

\subsection{struct}

C 语言的 struct 声明一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用 struct 的各个组成部分。类似于数组的实现，struct 的所有组成部分都存放在内存中一段连续的区域中，而指向 struct 的指针就是 struct 第一个字节的地址。编译器维护关于每个 struct 类型的信息，指示每个字段（field）的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对 struct 元素的引用。

\subsection{union}

union 提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。

\subsection{数据对齐}

许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K 的倍数。这种对齐限制简化了处理器和内存系统之间接口的硬件设计。例如，假设一个处理器总是从内存中取 8 个字节，则地址必须为 8 的倍数。如果我们能保证将所有的 double 类型数据的地址对齐成 8 的倍数，那么就可以用一个内存操作来读或者写值了，否则可能需要执行两次内存访问。

无论数据是否对齐，x86-64 硬件都能正确工作。不过，Intel 还是建议要对齐数据以提高内存系统的性能。对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数。

确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，就可保证实施对齐。编译器在汇编代码中放入命令。指明全局数据所需的对齐。例如，\verb|.align 8| 保证了它后面的数据的起始地址是 8 的倍数。

对于包含 struct 的代码，编译器可能需要在字段的分配中插入间隙，以保证每个 struct 元素都满足它的对齐要求。而 struct 本身对它的起始地址也有一些对齐要求。另外，struct 的末尾可能需要一些填充，这样 struct 数组中的每个元素都会满足它的对齐要求。

\section{在机器级程序中将控制与数据结合起来}

\subsection{理解指针}

\begin{itemize}
    \item 每个指针都对应一个类型。指针类型不是机器代码中的一部分，它们是 C 语言提供的一种抽象，帮助程序员避免寻址错误。
    \item 每个指针都有一个值。这个值是某个指定类型的对象的地址。特殊的 \verb|NULL(0)| 值表示该指针没有指向任何地方。
    \item 指针用 \& 运算符创建。这个运算符可以应用到任何 lvalue 类的 C 表达式。
    \item * 操作符用于间接引用指针。其结果是一个值，它的类型与该指针的类型一致。
    \item 数组与指针紧密联系。一个数组的名字可以像一个指针变量一样引用。
    \item 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。
    \item 指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。
\end{itemize}

\subsection{应用：使用 GDB 调式器}

略。参考别的 GDB 教程。

\subsection{内存越界引用和缓冲区溢出}

C 对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。这两种情况结合到一起就能导致园中的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，视图重新加载寄存器或执行 \verb|ret| 指令时，就会出现很严重的错误。

一种特别常见的状态破坏称为缓冲区溢出（buffer overflow）。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。示例略。

\subsection{对抗缓冲区溢出攻击}

\subsubsection{栈随机化}

为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要指导这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相对固定的。

栈随机化的思想使得栈的位置在程序每次运行时都有变化。实现的方式是：程序开始时，在栈上分配一段 0 \~{} n 字节之间的随机大小的空间，程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。

在 Linux 系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化（Address-Space Layout Randomization）。采用 ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。

\subsubsection{栈破坏检测}

计算机的第二道防线是能够检测到何时栈已经被破坏。在 C 语言中，没有可靠的方法来防止对数组的越界写。但是，我们能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。

GCC 在产生的代码中加入了一种栈保护者（stack protector）机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（canary）值，也叫哨兵值（guard value），是在程序每次运行时随机产生。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果使得，那么程序异常中止。

\subsubsection{限制可执行代码区域}

最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的，区域部分部分可以被限制为只允许读和写。AMD 和 Intel 为 64 位处理器的内存保护引入了 NX（No-Execute）位，将读和执行访问模式分开。有了这个特性，栈可以被标记为可读和可写，但是不可执行，而检查页是否可执行由硬件来完成，效率上没有损失。

\subsection{支持变长栈帧}

有些函数，需要的局部存储是变长的，当代码声明一个局部变长数组时，会发生这种情况。示例待补充。

为了管理变长帧栈，x86-64 代码使用寄存器 \verb|%rbp| 作为帧指针（frame pointer），优势称为 base pointer。待补充。

\section{浮点代码}

AVX 浮点体系结构允许数据存储在 16 歌 YMM 寄存器中，它们的名字为 \verb|%ymm0| \~{} \verb|%ymm15|。每个 YMM 寄存器都是 256 位。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低 32 位（对于 float）或者 64 位（对于 double）。汇编代码用寄存器的 SSE XMM 寄存器名字 \verb|%xmm0| \~{} \verb|%xmm15| 来引用它们，每个 XMM 寄存器都是对应的 YMM 寄存器的低 128 位。

\begin{figure}[!p]
    \centering
    \begin{tikzpicture}
        \foreach \t [count=\x] in {
            1st FP arg./Return value,
            2nd FP argument,
            3rd FP argument,
            4th FP argument,
            5th FP argument,
            6th FP argument,
            7th FP argument,
            8th FP argument,
            Caller saved,
            Caller saved,
            Caller saved,
            Caller saved,
            Caller saved,
            Caller saved,
            Caller saved,
            Caller saved
        } {
            \draw[fill=White!60!ProcessBlue] (0, -1.4 * \x + 0.5) rectangle (14, -1.4 * \x - 0.5);
            \draw[fill=White] ($(7, -1.4 * \x + 0.5) + (0, -2pt)$) rectangle ($(14, -1.4 * \x - 0.5) + (-2pt, 2pt)$);
            \node[right] at (0, -1.4 * \x) {\texttt{\%ymm\x}};
            \node[right] at (7, -1.4 * \x) {\texttt{\%xmm\x}};
            \node[right] at (14, -1.4 * \x) {\t};
        }
        \node[above] at (0, -0.5) {255};
        \node[above] at (7, -0.5) {127};
        \node[above] at (14, -0.5) {0};
    \end{tikzpicture}
\end{figure}

\subsection{浮点传送和转换操作}

下表给出了一组在内存和 XMM 寄存器之间以及从一个 XMM 寄存器到另一个不做任何转换的传送浮点数的指令。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议 32 位内存数据满足 4 字节对齐，64 位数据满足 8 字节对齐。内存引用的指定方式与整数 MOV 指令的一样，包括偏移量
基址寄存器、变址寄存器和伸缩因子的所有可能的组合。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lccl}
        \toprule
        Instruction & Source & Destination & Description \\
        \midrule
        \texttt{vmovss} & $M_{32}$ & $X$ & Move single precision \\
        \texttt{vmovss} & $X$ & $M_{32}$ & Move single precision \\
        \texttt{vmovsd} & $M_{64}$ & $X$ & Move double precision \\
        \texttt{vmovsd} & $X$ & $M_{64}$ & Move double precision \\
        \texttt{vmovaps} & $X$ & $X$ & Move aligned, packed single precision \\
        \texttt{vmovapd} & $X$ & $X$ & Move aligned, packed double precision \\
        \bottomrule
    \end{tabular}
\end{table}

GCC 只用 \verb|vmovss| 和 \verb|vmovsd| 指令从内存传送数据到 XMM 寄存器或从 XMM 寄存器传送数据到内存，用 \verb|vmovaps| 和 \verb|vmovapd| 指令在两个 XMM 寄存器之间传送数据。a 表示 aligned，当用于读写内存时，如果地址不满足 16 字节对齐，会导致异常。

下表中的指令把一个从 XMM 寄存器或内存中读出的浮点数进行转换，并将结果写入一个通用寄存器中。把浮点数转换成整数时，指令会执行 truncation，把值向 0 进行舍入。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lccl}
        \toprule
        Instruction & Source & Destination & Description \\
        \midrule
        \texttt{vcvttss2si} & $X/M_{32}$ & $R_{32}$ & Convert with truncation single precision to integer \\
        \texttt{vcvttsd2si} & $X/M_{64}$ & $R_{32}$ & Convert with truncation double precision to integer \\
        \texttt{vcvttss2siq} & $X/M_{32}$ & $R_{64}$ & Convert with truncation single precision to quad word integer \\
        \texttt{vcvttsd2siq} & $X/M_{64}$ & $R_{64}$ & Convert with truncation double precision to quad word integer \\
        \bottomrule
    \end{tabular}
\end{table}

下表中的指令把整数转换成浮点数。它们使用的是三操作数格式，由两个源和一个目的。第一个操作数读自于内存或一个通用目的寄存器。这里可以忽略第二个操作数，因为它的值只会影响结果的高位字节，而我们的目标必须是 XMM 寄存器。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lcccl}
        \toprule
        Instruction & Source1 & Source2 & Destination & Description \\
        \midrule
        \texttt{vcvtsi2ss} & $M_{32}/R_{32}$ & $X$ & $X$ & Convert integer to single precision \\
        \texttt{vcvtsi2sd} & $M_{32}/R_{32}$ & $X$ & $X$ & Convert integer to doubel precision \\
        \texttt{vcvtsi2ssq} & $M_{64}/R_{64}$ & $X$ & $X$ & Convert quad word integer to single precision \\
        \texttt{vcvtsi2sdq} & $M_{64}/R_{64}$ & $X$ & $X$ & Convert quad word integer to double precision \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{过程中的浮点代码}

在 x86-64 中，XMM 寄存器用来向函数传递浮点参数，以及从函数返回浮点值。有如下规则：

\begin{itemize}
    \item XMM 寄存器 \verb|%xmm0| \~{} \verb|%xmm7| 最多可以传递 8 个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。
    \item 函数使用寄存器 \verb|%xmm0| 来返回浮点值。
    \item 所有的 XMM 寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。
\end{itemize}

当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点数通过 XMM 寄存器传递。

\subsection{浮点运算操作}

下表描述了一组执行运算的标量 AVX2 浮点指令。每条指令有一个 ($S_1$) 或两个 ($S_1$, $S_2$) 源操作数，和一个目的操作数 $D$。第一个源操作数 $S_1$ 可以是一个 XMM 寄存器或一个内存位置。第二个源操作数和目的操作数都必须是 XMM 寄存器。每个操作都有一条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        Single & Double & Effect & Description \\
        \midrule
        \texttt{vaddss} & \texttt{vaddsd} & $D \leftarrow S_2 + S_1$ & Floating-point add \\
        \texttt{vsubss} & \texttt{vsubsd} & $D \leftarrow S_2 - S_1$ & Floating-point subtract \\
        \texttt{vmulss} & \texttt{vmulsd} & $D \leftarrow S_2 \times S_1$ & Floating-point multiply \\
        \texttt{vdivss} & \texttt{vdivsd} & $D \leftarrow S_2 / S_1$ & Floating-point divide \\
        \texttt{vmaxss} & \texttt{vmaxsd} & $D \leftarrow max(S_2, S_1)$ & Floating-point maximum \\
        \texttt{vminss} & \texttt{vminsd} & $D \leftarrow min(S_2, S_1)$ & Floating-point minimum \\
        \texttt{sqrtss} & \texttt{sqrtsd} & $D \leftarrow \sqrt{S_1}$ & Floating-point square root \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{定义和使用浮点常数}

和整数运算不同，AVX 浮点操作不能以立即数作为操作数，编译器必须为所有的常量值分配和初始化存储空间，然后再把这些值从内存中读入。例如：

\begin{cppcode}
double cel2fahr(double temp) {
  return 1.8 * temp + 32.0;
}
\end{cppcode}

相应的 x86-64 汇编代码如下：

\begin{gascode}
# double cel2fahr(double temp)
# temp in %xmm0
.LCPI0_0:
    .quad   4610785298501913805     # double 1.8
.LCPI0_1:
    .quad   4629700416936869888     # double 32
cel2fahr:
    mulsd   .LCPI0_0(%rip), %xmm0   # Multiply by 1.9
    addsd   .LCPI0_1(%rip), %xmm0   # Add 32.0
    retq
\end{gascode}

\subsection{在浮点代码中使用位级操作}

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        Single & Double & Effect & Description \\
        \midrule
        \texttt{vxorps} & \texttt{vxorpd} & $D \leftarrow S_2 \^{} S_1$ & Bitwise \textsc{exclusive-or} \\
        \texttt{vandps} & \texttt{vandpd} & $D \leftarrow S_2 \& S_1$ & Bitwise \textsc{and} \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{浮点比较指令}

AVX2 提供了两条用于比较浮点数值的指令：

\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        Instruction & Based on & Description \\
        \midrule
        \texttt{ucomiss} $S_1$, $S_2$ & $S_2 - S_1$ & Compare single precision \\
        \texttt{ucomisd} $S_1$, $S_2$ & $S_2 - S_1$ & Compare double precision \\
        \bottomrule
    \end{tabular}
\end{table}

参数 $S_2$ 必须在 XMM 寄存器中，而 $S_1$ 可以在 XMM 寄存器中，也可以在内存中。

浮点比较指令会设置三个条件码：零标志位 ZF、进位标志位 CF 和奇偶标志位 PF。对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶检验的（即这个字节中有偶数个 1），那么就会设置 PF 标志位；对于浮点比较，当两个操作数中任一个是 NaN 时，会设置该位。

条件码的设置条件如下：
\begin{table}[!ht]
    \centering
    \begin{tabular}{lccc}
        \toprule
        Ordering $S_2 : S_1$ & CF & ZF & PF \\
        \midrule
        Unordered & 1 & 1 & 1 \\
        $S_2 < S_1$ & 1 & 0 & 0 \\
        $S_2 = S_1$ & 0 & 1 & 0 \\
        $S_2 > S_1$ & 0 & 0 & 0 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{对浮点代码的观察结论}

我们可以看到，用 AVX2 为浮点数上的操作产生的机器代码风格类似于为整数上的操作产生的代码风格。它们都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数。AVX2 还有能力在封装号的数据上执行并行操作，使计算执行得更快。编译器开发者正致力于自动化从标量代码到并行代码的转换。

\section{小结}

在本章中，我们窥视了 C 语言提供的抽象层下面的东西，以了解机器级编程。通过让编译器产生机器级程序的汇编代码表示，我们了解了编译器和它的优化能力，以及机器、数据类型和指令集。在第 5 章，我们会看到，当编写能有效映射到机器上的程序时，了解编译器的特性会有所帮助。我们还更完整地了解了程序如何将数据存储在不同的内存区域中。应用程序员需要知道一个程序变量是在运行时栈中，是在某个动态分配的数据结构中，还是全局程序数据的一部分。理解程序如何映射到机器上，会让理解这些存储类型之间的区别容易一些。

机器级程序和它们的汇编代码表示，与 C 程序的差别很大。各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。编译器必须使用多条指令来产生和操作各种数据结构，以及实现像条件、循环和过程这样的控制结构。我们讲述了 C 语言和如何编译它的许多不同方面。我们看到 C 语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。

我们只分析了 C 到 x86-64 的映射，但是大多数内容对其他语言和机器组合来说也是类似的。相比而言，Java 的实现方式完全不同。Java 的目标代码是一种特殊的二进制表示，称为 Java 字节代码。这种代码可以看成是虚拟机的机器级程序，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。另外，有一种称为 just-in-time compilation 的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时，这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在不同的机器上执行，而在本章谈到的机器代码只能在 x86-64 机器上运行。
\endinput
