\chapter{程序的机器级表示}

计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的管理，经过一系列的阶段生成机器代码。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

\section{历史观点}

Intel 处理器系列俗称 x86,经历了一个长期的、不断进化的发展过程。

8086 是第一代单芯片、16位微处理器；i386 将体系结构扩展到 32 位，增加了平坦寻址模式（flat addressing model）；Pentium III 引入了 SSE 指令；Pentium 4 扩展到了 SSE2；Pentium 4E 增加了超线程；Core i7 Nehalem 同时支持超线程和多核；Core i7 Sandy Bridge 引入了 AVX；Core i7 Haswell 扩展到了 AVX2。

\section{程序编码}

\subsection{机器级代码}

计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。第一种是 ISA 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA，包括 x86，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

在整个编译过程中，编译器会完成大部分的工作，将把 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。x86-64 的机器代码和原始的 C 代码差别很大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：

\begin{itemize}
    \item 程序计数器（PC，在 x86-64 中用 \verb|%rip| 来表示）给出要执行的下一条指令在内存中的地址。
    \item 整数寄存器堆（共 16 个寄存器），分别存储 64 位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
    \item 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息，通常用于控制流或者条件传送。
    \item 一组向量寄存器可以存放一个或多个整数或浮点数值。
\end{itemize}

\subsection{代码示例}

假设 C 语言代码文件 \verb|mstore.c|：

\begin{cppcode}
long mult2(long, long);

void multstore(long x, long y, long *dest) {
  long t = mult2(x, y);
  *dest = t;
}
\end{cppcode}

在命令行上使用 \verb|-S| 选项，就能看到产生的汇编代码：\verb|gcc -Og -S mstore.c| 或者 \verb|clang -Og -S mstore.c|。

汇编代码文件包含各种声明，包含下面几行：

\begin{gascode}
multstore:
    pushq   %rbx
    movq    %rdx, %rbx
    callq   mult2
    movq    %rax, (%rbx)
    popq    %rbx
    retq
\end{gascode}

如果使用 \verb|-c| 选项，会编译并汇编该代码：\verb|gcc -Og -c mstore.c| 或者 \verb|clang -Og -c mstore.c|。

这就会产生目标代码文件 \verb|mstore.o|，它是二进制格式的，所以无法直接查看。

\marginpar{\footnotesize 要展示程序（比如 mstore）的二进制目标代码，可以用反汇编器确定该过程的代码长度是 14 字节。然后，在文件 mstore.o 上运行调试工具 GDB，输入命令：x/14xb multstore。这条命令会让调试器显示从函数 multstore 所处地址开始的 14 个十六进制格式表示的字节。}

要查看机器代码文件的内容，有一类称为反汇编器（disassembler）的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。\verb|objdump -d mstore.o| 或者\\ \verb|llvm-objdump -d mstore.o|。

结果如下：

\begin{textcode}
0000000000000000 multstore:
    0: 53                               pushq   %rbx
    1: 48 89 d3                         movq    %rdx, %rbx
    4: e8 00 00 00 00                   callq   0 <multstore+0x9>
    9: 48 89 03                         movq    %rax, (%rbx)
    c: 5b                               popq    %rbx
    d: c3                               retq
\end{textcode}

其中一些关于机器代码和它的反汇编表示的特性值得主义：

\begin{itemize}
    \item x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少额度指令所需的字节数少，而哪些不太常用或操作数较多的指令所需字节数较多。
    \item 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。
    \item 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它不需要访问该程序的源代码或者汇编代码。
    \item 反汇编器使用的指令命名规则可能与生成的汇编代码有一些细微的区别（常见于 objdump 和 GCC）。
\end{itemize}

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须包含有一个 \verb|main| 函数。假设有文件 \verb|main.c|：

\begin{cppcode}
#include <stdio.h>

void multstore(long, long, long *);

int main() {
  long d;
  multstore(2, 3, &d);
  printf("2 * 3 --> %ld\n", d);
  return 0;
}
long mult2(long a, long b) {
  long s = a * b;
  return s;
}
\end{cppcode}

然后，生成可执行文件 \verb|prog|：\verb|clang -Og -o prog main.c mstore.c|。文件 \verb|prog| 的体积变得很大，因为它不仅包含了两个函数的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。反汇编 \verb|prog| 文件：\verb|llvm-objdump -d prog|。

反汇编器会抽取出各种代码序列，包括下面这段：

\begin{textcode}
0000000000401170 multstore:
  401170: 53                            pushq   %rbx
  401171: 48 89 d3                      movq    %rdx, %rbx
  401174: e8 e7 ff ff ff                callq   -25 <mult2>
  401179: 48 89 03                      movq    %rax, (%rbx)
  40117c: 5b                            popq    %rbx
  40117d: c3                            retq
  40117e: 66 90                         nop
\end{textcode}

这段代码与 \verb|mstore.c| 反汇编产生的代码几乎完全一样。其中一个主要的区别是左边列出的地址不同（链接器将这段代码的地址移到了一段不同的地址范围中）。第二个不同之处在于链接器填上了 \verb|callq| 指令调用函数 \verb|mult2| 需要使用的地址。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是多了一条 \verb|nop| 指令，插入 \verb|nop| 的作用是为了使函数代码变为 16 字节，使得就存储器系统性能而言，能够更好地放置下一个代码块。

\subsection{关于格式的注解}

所有以 \verb|.| 开头的都是指导汇编器和链接器工作的伪指令。通常可以忽略。

\subsubsection{AT\&T 与 Intel 汇编代码格式}

我们的表述是 AT\&T 格式的汇编代码，这是 GCC、OBJDUMP 等工具的默认格式。微软的工具和 Intel 的文档，其汇编代码是 Intel 格式的。可以使用 \verb|clang -Og -S -masm=intel mstore.c| 产生 \verb|multstore| 函数的 Intel 格式的代码：

\begin{nasmcode}
multstore:
    push    rbx
    mov     rbx, rdx
    call    mult2@PLT
    mov     qword ptr [rbx], rax
    pop     rbx
    ret
\end{nasmcode}

可以看到 Intel 和 AT\&T 格式再如下方面有所不同：

\begin{itemize}
    \item Intel 格式省略了指示大小的后缀（push 而非 pushq）。
    \item Intel 格式省略了寄存器名字前面的 \verb|%| 号。
    \item Intel 格式用不同大方式来描述内存中的位置（\verb|qword ptr [rbx]| 而非 \verb|(%rbx)|）。
    \item 在带有多个操作数的指令情况下，列出操作数的顺序相反。
\end{itemize}

\section{数据格式}

由于 x86 是从 16 位体系结构扩展而来的，Intel 用术语字（word）表示 16 位数据类型，因此，称 32 位数为 double words 或 long word，称 64 位数为 quad words。AT\&T 格式的汇编代码指令大部分都有一个字符的后缀，表明操作数的大小，如下表所示。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llcc}
        \toprule
        C declaration & Intel data type & Assembly-code suffix & Size(bytes) \\
        \midrule
        char    & Byte              & \verb|b|  & 1 \\
        short   & Word              & \verb|w|  & 2 \\
        int     & Double word       & \verb|l|  & 4 \\
        long    & Quad word         & \verb|q|  & 8 \\
        char *  & Quad word         & \verb|q|  & 8 \\
        float   & Single precision  & \verb|s|  & 4 \\
        double  & Double precision  & \verb|l|  & 8 \\
        \bottomrule
    \end{tabular}
\end{table}

注意，Double word 和 Double precision 使用同样的后缀 \verb|l|，这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

\section{访问信息}

一个 x86-64 的 CPU 包含一组 16 个 64 位值的通用寄存器，用来存储整数数据和指针，它们的名字都以 \verb|%r| 开头，最初的 8086 有 8 个 16 位的寄存器，即图中的 \verb|%ax| 到 \verb|%bp|。每个寄存器都有特殊的用途，它们的名字就反映了它们的用途。扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 \verb|%eax| 到 \verb|%ebp|。扩展到 x86-64 后，同样扩展成 64 位寄存器，标号从 \verb|%rax| 到 \verb|%rbp|。除此之外，还增加了 8 个新的寄存器，它们的标号时按照新的命名规则指定的，从 \verb|%r8| 到 \verb|%r15|。

\begin{figure}[!p]
    \centering
    \begin{tikzpicture}
        \foreach \r/\e/\w/\b/\t [count=\x] in {
            rax/eax/ax/al/Return value,
            rbx/ebx/bx/bl/Callee saved,
            rcx/ecx/cx/cl/4th argument,
            rdx/edx/dx/dl/3rd argument,
            rsi/esi/si/sil/2nd argumrnt,
            rdi/edi/di/dil/1st argument,
            rbp/ebp/bp/bpl/Callee saved,
            rsp/esp/sp/spl/Stack pointer,
            r8/r8d/r8w/r8b/5th argument,
            r9/r9d/r9w/r9b/6th argument,
            r10/r10d/r10w/r10b/Caller saved,
            r11/r11d/r11w/r11b/Caller saved,
            r12/r12d/r12w/r12b/Callee saved,
            r13/r13d/r13w/r13b/Callee saved,
            r14/r14d/r14w/r14b/Callee saved,
            r15/r15d/r15w/r15b/Callee saved
        } {
            \draw[fill=White!60!ProcessBlue] (0, -1.4 * \x + 0.5) rectangle (16, -1.4 * \x - 0.5);
            \draw[fill=White!90!ProcessBlue] ($(8, -1.4 * \x + 0.5) + (0, -2pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-2pt, 2pt)$);
            \draw[fill=White] ($(12, -1.4 * \x + 0.5) + (0, -4pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-4pt, 4pt)$);
            \draw[fill=White, thick] ($(14, -1.4 * \x + 0.5) + (0, -6pt)$) rectangle ($(16, -1.4 * \x - 0.5) + (-6pt, 6pt)$);
            \node[right] at (0, -1.4 * \x) {\texttt{\%\r}};
            \node[right] at (8, -1.4 * \x) {\texttt{\%\e}};
            \node[right] at (12, -1.4 * \x) {\texttt{\%\w}};
            \node[right] at (14, -1.4 * \x) {\texttt{\%\b}};
            \node[right] at (16, -1.4 * \x) {\t};
        }
        \node[above] at (0, -0.5) {63};
        \node[above] at (8, -0.5) {31};
        \node[above] at (12, -0.5) {15};
        \node[above] at (14, -0.5) {7};
        \node[above] at (16, -0.5) {0};
    \end{tikzpicture}
\end{figure}

\subsection{操作数指示符}

大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64 支持多种操作格式。第一种类型是立即数（immediate），用来表示常数值。在 AT\&T 格式的汇编代码中，立即数的书写方式是 \$ 后面跟一个用标准 C 表示法表示的整数。第二种类型是寄存器（register），表示某个寄存器的内容。我们用符号 $r_a$ 来表示任意寄存器 $a$，用引用 $R[r_a]$ 来表示它的值。第三种操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。我们用符号 $M_b[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始的 $b$ 个字节值的引用。为了简便，通常省去下标 $b$。

如下表所示，x86-64 还支持多种寻址模式。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        Type & Form & Operand value & Name \\
        \midrule
        Immediate & \$$Imm$ & $Imm$ & Immediate \\
        \\
        Register & $r_a$ & $R[r_a]$ & Register \\
        \\
        Memory & $Imm$              & $M[Imm]$                              & Absolute \\
        Memory & $(r_a)$            & $M[R[r_a]]$                           & Indirect \\
        Memory & $Imm(r_b)$         & $M[Imm + R[r_b]]$                     & Base + displacement \\
        Memory & $(r_b, r_i)$       & $M[R[r_b] + R[r_i]]$                  & Indexed \\
        Memory & $Imm(r_b, r_i)$    & $M[Imm + R[r_b] + R[r_i]]$            & Indexed \\
        Memory & $(, r_i, s)$       & $M[R[r_i] \cdot s]$                   & Scaled indexed \\
        Memory & $Imm(, r_i, s)$    & $M[Imm + R[r_i] \cdot s]$             & Scaled indexed \\
        Memory & $(r_b, r_i, s)$    & $M[R[r_b] + R[r_i] \cdot s]$          & Scaled indexed \\
        Memory & $Imm(r_b, r_i, s)$ & $M[Imm + R[r_b] + R[r_i] \cdot s]$    & Scaled indexed \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{数据传送指令}

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

MOV 类指令将数据从原位置复制到目的位置，不做任何变化。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        MOV                & $S, D$ & $D \leftarrow S$  & Move \\
        \quad\texttt{movb} &        &                   & Move byte \\
        \quad\texttt{movw} &        &                   & Move word \\
        \quad\texttt{movl} &        &                   & Move double word \\
        \quad\texttt{movq} &        &                   & Move quad word \\
        \texttt{movabsq}   & $I, R$ & $R \leftarrow I$  & Move absolute word \\
        \bottomrule
    \end{tabular}
\end{table}

\marginpar{\footnotesize 造成这个例外的原因是 x86-64 采用的惯例，即任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分设置为 0。}

源操作数可以是立即数、寄存器或者内存中的值，目的操作数可以是寄存器或者是内存地址。x86-64 限制 传送指令的两个操作数不能同时指向内存。大多数情况下，MOV 指令只会更新目的操作数指定的寄存器字节或者内存位置。唯一的例外是 \verb|movl| 指令以寄存器作为目的时。它会把该寄存器的高 4 字节设置为 0。

MOVZ 类指令把目的中剩余的字节填充为 0,而 MOVS 类指令填充为符号位。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        Instruction & Effect & Description \\
        \midrule
        MOVZ \quad $S, R$ & $R \leftarrow ZeroExtend(S)$ & Move with zero extension \\
        \quad\texttt{movzbw} & & Move zero-extended byte to word \\
        \quad\texttt{movzbl} & & Move zero-extended byte to double word \\
        \quad\texttt{movzwl} & & Move zero-extended word to doubel word \\
        \quad\texttt{movzbq} & & Move zero-extended byte to quad word \\
        \quad\texttt{movzwq} & & Move zero-extended word to quad word \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        Instruction & Effect & Description \\
        \midrule
        MOVS \quad $S, R$ & $R \leftarrow SignExtend(S)$ & Move with sign extension \\
        \quad\texttt{movsbw} & & Move sign-extended byte to word \\
        \quad\texttt{movsbl} & & Move sign-extended byte to double word \\
        \quad\texttt{movswl} & & Move sign-extended word to double word \\
        \quad\texttt{movsbq} & & Move sign-extended byte to quad word \\
        \quad\texttt{movswq} & & Move sign-extended word to quad word \\
        \quad\texttt{movslq} & & Move sign-extended double to quad word \\
        \texttt{cltq} & $\texttt{\%rax} \leftarrow SignExtend(\texttt{\%eax})$ & Sign-extend \texttt{\%eax} to \texttt{\%rax} \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{数据传送示例}

略。

\subsection{压入和弹出栈数据}

栈是一种数据结构，可以添加或者删除值，遵循后进先出的原则。通过 push 操作把数据压入栈中，通过 pop 操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一段插入和删除元素。这一端被称为栈顶。x86-64 中，程序栈存放在内存中某个区域。栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址最低的。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{pushq} & $S$ & $R[\texttt{\%rsp}] \leftarrow R[\texttt{\%rsp}] - 8$; & Push quad word \\
        & & $M[R[\texttt{\%rsp}]] \leftarrow S$ & \\
        \texttt{popq} & $D$ & $D \leftarrow M[R[\texttt{\%rsp}]]$; & Pop quad word \\
        & & $R[\texttt{\%rsp}] \leftarrow R[\texttt{\%rsp}] + 8$ & \\
        \bottomrule
    \end{tabular}
\end{table}

\verb|pushq| 指令的功能是把数据压入到栈上，而 \verb|popq| 指令是弹出数据，这两条指令都只有一个操作数。

\section{算术和逻辑操作}

下表列出了 x86-64 的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有四种带不同大小操作数的变种。\marginpar{\footnotesize 只有 \texttt{leaq} 没有其他大小的变种。}这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{leaq} & $S, D$ & $D \leftarrow \&S$ & Load effective address \\
        \\
        INC  & $D$    & $D \leftarrow D + 1$    & Increment \\
        DEC  & $D$    & $D \leftarrow D - 1$    & Decrement \\
        NEG  & $D$    & $D \leftarrow -D$       & Negate \\
        NOT  & $D$    & $D \leftarrow ~D$       & Complement \\
        \\
        ADD  & $S, D$ & $D \leftarrow D + S$  & Add \\
        SUB  & $S, D$ & $D \leftarrow D - S$  & Subtract \\
        IMUL & $S, D$ & $D \leftarrow D * S$  & Multiply \\
        XOR  & $S, D$ & $D \leftarrow D ^ S$  & Exclusive-or \\
        OR   & $S, D$ & $D \leftarrow D | S$  & Or \\
        AND  & $S, D$ & $D \leftarrow D \& S$ & And \\
        \\
        SAL  & $k, D$ & $D \leftarrow D << k$ & Left shift \\
        SHL  & $k, D$ & $D \leftarrow D << k$ & Left shift(same as SAL) \\
        SAR  & $k, D$ & $D \leftarrow D >>_A k$ & Arithmetic right shift \\
        SHR  & $k, D$ & $D \leftarrow D >>_L k$ & Logical right shift \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{加载有效地址}

load effective address 指令 \verb|leaq| 实际上是 \verb|movq| 指令的变形，该指令的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。另外，它还可以简洁地描述普通的算术操作。编译器经常利用 \verb|leaq| 的一些灵活用法，根本就与有效地址计算无关。例如：

\begin{cppcode}
long scale(long x, long y, long z) {
  long t = x + 4 * y + 12 * z;
  return t;
}
\end{cppcode}

编译时，该函数的算术运算以三条 \verb|leaq| 指令实现：

\begin{gascode}
# long scale(long x, long y, long z)
# x in %rdi, y in %rsi, z in %rdx
scale:
    leaq    (%rdi,%rsi,4), %rax     # x + 4*y
    leaq    (%rdx,%rdx,2), %rcx     # z + 2*z = 3*z
    leaq    (%rax,%rcx,4), %rax     # (x+4*y) + 4*(3*z) = x + 4*y + 12*z
    retq
\end{gascode}

\subsection{一元和二元操作}

一元操作只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。二元操作有两个操作数，其中第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或者内存位置，第二个操作数可以是寄存器或者内存位置。

\subsection{移位操作}

移位操作的第一个操作数是移位量，第二个操作数是要移位的数。移位量可以是一个立即数，或者放在单字节寄存器 \verb|%cl| 中。

\subsection{讨论}

大多数指令，既可以用于无符号运算，又可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算可以实现有符号整数运算。

\subsection{特殊的算术运算}

2 个 64 位有符号或者无符号整数相乘得到的乘积需要 128 位来表示，x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。Intel 把 16 字节的数称为 oct word。下表展示了产生 128 位数的指令：

\begin{table}[!ht]
    \centering
    \begin{tabular}{llll}
        \toprule
        \multicolumn{2}{l}{Instruction} & Effect & Description \\
        \midrule
        \texttt{imulq} & $S$ & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow S \times R[\texttt{\%rax}]$ & Signed full multiply \\
        \texttt{mulq} & $S$ & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow S \times R[\texttt{\%rax}]$ & Unsigned full multiply \\
        \\
        \texttt{cqto} & & $R[\texttt{\%rdx}]:R[\texttt{\%rax}] \leftarrow SignExtend(R[\texttt{\%rax}])$ & Convert to oct word \\
        \\
        \texttt{idivq} & $S$ & $R[\texttt{\%rdx}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \bmod S$; & Signed divide \\
        & & $R[\texttt{\%rax}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \div S$ & \\
        \texttt{divq} & $S$ & $R[\texttt{\%rdx}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \bmod S$; & Unsigned divide \\
        & & $R[\texttt{\%rax}] \leftarrow R[\texttt{\%rdx}]:R[\texttt{\%rax}] \div S$ & \\
        \bottomrule
    \end{tabular}
\end{table}

\verb|imulq| 指令有两种不同的形式。其中一种，是 IMUL 指令类中的一种。这种形式的 \verb|imulq| 指令是一个双操作数乘法指令，它从两个 64 位操作数产生一个 64 位乘积。

此外，x86-64 还提供了两条单操作数乘法指令，以计算两个 64 位数的全 128 位乘积，都要求一个参数必须在寄存器 \verb|%rax| 中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器 \verb|%rdx|（高 64 位）和 \verb|%rax|（低 64 位）中。

前面的算术运算表没有列出除法或取模操作。这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。

\endinput
