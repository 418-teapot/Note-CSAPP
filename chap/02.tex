\chapter{信息的表示和处理}

我们研究三种最重要的数字表示。无符号（unsignd）编码基于传统的二进制表示法，表示大于或者等于零的数字。补码（two's-complement）编码是表示有符号整数的最常见的方式。浮点数（floating-point）编码是表示实数的科学计数法的以 2 为基数的版本。

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会溢出（overflow）。

\section{信息存储}

大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory)。内存的每个字节都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合就称为虚拟地址空间（virtual address space）。

\subsection{十六进制表示法}

略。

\subsection{字数据大小}

每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0 \~{} 2^w - 1$ ，程序最多访问 $2^w$ 个字节。

下表展示了为 C 语言各种数据类型分配的字节数。

\begin{table}[!ht]
    \centering
    \begin{tabular}{ccccc}
        \toprule
        \multicolumn{2}{c}{C declaration} & & \multicolumn{2}{c}{Bytes} \\
        \cmidrule{1-2}
        \cmidrule{4-5}
        Signed & Unsigned & & 32-bit & 64-bit \\
        \midrule
        (signed) char  & unsigned char  & & 1 & 1 \\
        short          & unsigned char  & & 2 & 2 \\
        int            & unsigned       & & 4 & 4 \\
        long           & unsigned long  & & 4 & 8 \\
        int32\_t       & uint32\_t      & & 4 & 4 \\
        int64\_t       & uint64\_t      & & 8 & 8 \\
        char *         &                & & 4 & 8 \\
        float          &                & & 4 & 4 \\
        double         &                & & 8 & 8 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{寻址和字节顺序}

对于跨越多字节的程序对象，必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

排列一个对象的字节有两种规则。考虑一个 $w$ 位的整数，其位表示为 $[x_{w-1}, x_{w-2}, \dots, x_1, x_0]$，其中 $x_{w-1}$ 是最高有效位，而 $x_0$ 是最低有效位。假设 $w$ 是 8 的倍数，这些位就能被分组成字节，其中最高有效字节包含位 $[x_{w-1}, x_{w-2}, \dots, x_{w-8}]$，而最低有效字节包含位 $[x_7, x_6, \dots, x_0]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象；而另一个机器则按照从最高有效字节到最低有效字节的顺序存储。分别被称为小端序（little endian）和大端序（big endian）。

假设变量 \verb|x| 的类型为 \verb|int|，位于地址 \verb|0x100| 处，它的 16 进制值为 \verb|0x01234567|。地址范围 \verb|0x100~0x103| 的字节顺序依赖于机器的类型：

\begin{tikzfig}
    \coordinate (A) at (0, 0);
    \coordinate (B) at (10, 0);
    \coordinate (C) at (0, -1.2em);
    \coordinate (D) at (B |- C);
    \coordinate (E) at ($(A) + (0, -2)$);
    \coordinate (F) at ($(B) + (0, -2)$);
    \coordinate (G) at ($(C) + (0, -2)$);
    \coordinate (H) at ($(D) + (0, -2)$);

    \foreach \i in {1, 2, ..., 6} {
        \coordinate (cd\i) at ($(C)!\i/6!(D)$);
        \coordinate (gh\i) at ($(G)!\i/6!(H)$);
        \ifthenelse {\i < 6} {
            \draw (cd\i) -- (A -| cd\i);
            \draw (gh\i) -- (E -| gh\i);
        } {}
    }
    
    \draw (A) -- node[above, yshift=5pt]{大端序} (A -| cd1)
              -- node[above]{0x100} (A -| cd2)
              -- node[above]{0x101} (A -| cd3)
              -- node[above]{0x102} (A -| cd4)
              -- node[above]{0x103} (A -| cd5)
              -- (B);
    \draw (C) -- node[above]{$\cdots$} (cd1)
              -- node[above]{01} (cd2)
              -- node[above]{23} (cd3)
              -- node[above]{45} (cd4)
              -- node[above]{67} (cd5)
              -- node[above]{$\cdots$} (D);

    \draw (E) -- node[above, yshift=5pt]{小端序} (E -| gh1)
              -- node[above]{0x100} (E -| gh2)
              -- node[above]{0x101} (E -| gh3)
              -- node[above]{0x102} (E -| gh4)
              -- node[above]{0x103} (E -| gh5)
              -- (F);
    \draw (G) -- node[above]{$\cdots$} (gh1)
              -- node[above]{67} (gh2)
              -- node[above]{45} (gh3)
              -- node[above]{23} (gh4)
              -- node[above]{01} (gh5)
              -- node[above]{$\cdots$} (H);
\end{tikzfig}

x86 使用小端序，IBM 和 Oracle 使用大端序，较新的处理器是双端序（bi-endian，如 ARM，可以配置为大端序或者小端序），但实际情况还取决于操作系统，如 Android 和 IOS 只能运行于小端序。

了解字节序的意义：1）不同端序的机器之间通过网络通信时；2）阅读反汇编代码时；3）C 语言通过 cast 或者 union 以一种数据类型引用另一种数据类型时。

\subsection{表示字符串}

C 语言中字符串被编码为一个以 null 字符结尾的字符数组。

\subsection{表示代码}

计算机系统的一个基本概念是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

\subsection{布尔代数简介}

略。

\subsection{C 语言中的位级运算}

略。

\subsection{C 语言中的逻辑运算}

略。

\subsection{C 语言中的移位运算}

C 语言中的 \verb|>>| 运算符对于有符号数是算术右移，对于无符号数是逻辑右移。

\section{整数表示}

下表为引入的数学术语，用于精确定义和描述计算机如何编码和操作整数。

\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
        \toprule
        Symbol & Type & Meaning \\
        \midrule
        $B2T_w$  & Function  & Binary to tow's complement \\
        $B2U_w$  & Function  & Binary to unsigned \\
        $U2B_w$  & Function  & Unsigned to binary \\
        $U2T_w$  & Function  & Unsigned to two's complement \\
        $T2B_w$  & Function  & Two's complement to binary \\
        $T2U_w$  & Function  & Two's complement to unsigned \\
        $TMin_w$ & Constant  & Minimum tow's-complement value \\
        $TMax_w$ & Constant  & Maximum two's-complement value \\
        $UMax_w$ & Constant  & Maximum unsigned value \\
        $+^t_w$  & Operation & Two's-complement addition \\
        $+^u_w$  & Operation & Unsigned addition \\
        $*^t_w$  & Operation & Two's-complement multiplication \\
        $*^u_w$  & Operation & Unsigned multiplication \\
        $-^t_w$  & Operation & Two's-complement negation \\
        $-^u_w$  & Operation & Unsigned negation \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{整型数据类型}

略。

\subsection{无符号数的编码}

\begin{definition}[Unsigned encoding]
    For vector $\vec{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$ :
    \begin{equation}
        B2U_w(\vec{x}) \doteq \sum\limits_{i=0}^{w-1} x_i 2^i
        \label{def:b2u}
    \end{equation}
\end{definition}

下图中，用长度为 $2^i$ 的指向右侧箭头的条表示每个位的位置 $i$。每个位向量对应的数值就等于所有值为 1 的位对应的条的长度之和。

\begin{tikzfig}
    \tikzset{arw/.style={>={Triangle[length=1.5mm, width=4mm]}, line width=4mm, draw=White!30!Cerulean}}
    \draw[arw, ->] (0, 0) node[left]{$2^3=8$} -- (4, 0);
    \draw[arw, ->] (0, -1.5em) node[left]{$2^2=4$} -- (2, -1.5em);
    \draw[arw, ->] (0, -3em) node[left]{$2^1=2$} -- (1, -3em);
    \draw[arw, ->] (0, -4.5em) node[left]{$2^0=1$} -- (0.5, -4.5em);

    \coordinate (A) at (0, -7em);
    \coordinate (B) at (8, -7em);
    \draw (A) -- (B);

    \foreach \i in {0, 1, 2, ..., 16} {
        \coordinate (ab\i) at ($(A)!\i/16!(B)$);
        \draw ($(ab\i) + (0, 2pt)$) node[above]{\i} -- ($(ab\i) - (0, 2pt)$);
    }

    \draw[arw, ->] (0, -8.5em) node[left]{$[0001]$} -- (0.5, -8.5em);
    \draw[arw, ->] (0, -10em) node[left]{$[0101]$} -- (2, -10em);
    \draw[arw, ->] (2, -10em) -- (2.5, -10em);
    \draw[arw, ->] (0, -11.5em) node[left]{$[1011]$} -- (4, -11.5em);
    \draw[arw, ->] (4, -11.5em) -- (5, -11.5em);
    \draw[arw, ->] (5, -11.5em) -- (5.5, -11.5em);
    \draw[arw, ->] (0, -13em) node[left]{$[1111]$} -- (4, -13em);
    \draw[arw, ->] (4, -13em) -- (6, -13em);
    \draw[arw, ->] (6, -13em) -- (7, -13em);
    \draw[arw, ->] (7, -13em) -- (7.5, -13em);

    \draw (A) -- (0, -13em-2mm);
    \draw (ab1) -- (0.5, -8.5em);
    \draw (ab5) -- (2.5, -10em);
    \draw (ab11) -- (5.5, -11.5em);
    \draw (ab15) -- (7.5, -13em);
\end{tikzfig}

考虑 $w$ 位所能表示的范围，最小值是用位向量 $[00\cdots0]$ 表示，也就是整数值 0, 而最大值是用位向量 $[11\cdots1]$ 表示，也就是整数值 $UMax_w \doteq \sum\limits_{i=0}^{w-1}2^i = 2^w - 1$ 。因此，函数 $B2U_w$ 能够被定义为一个映射 $B2U_w: \{0, 1\}^w \rightarrow \{0, \dots, UMax_w\}$。

无符号数的二进制表示有一个重要的属性，也就是每个介于 $0 \~{} 2^w-1$ 之间的数都有一个 $w$ 位的值编码。

\begin{theorem}[Uniqueness of unsigned encoding]
    Function $B2U_w$ is a bijection.

    Vice versa, function $U2B_w$ is a bijection.
\end{theorem}

\subsection{补码编码}

补码编码的原理：让 the most significant bit 拥有 negative weight。

\begin{definition}[Two's-complement encoding]
    For vector $\vec{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$ :
    \begin{equation}
        B2T_w(\vec{x}) \doteq -x_{w-1}2^{w-1} + \sum\limits_{i=0}^{w-2}x_i2^i
        \label{def:b2t}
    \end{equation}
\end{definition}

\begin{tikzfig}
    \tikzset{rarw/.style={>={Triangle[length=1.5mm, width=4mm]}, line width=4mm, draw=White!30!Cerulean}};
    \tikzset{larw/.style={>={Triangle[length=1.5mm, width=4mm]}, line width=4mm, draw=White!30!gray}};
    \draw[larw, ->] (0, 0) node[right]{$-2^3=-8$} -- (-4, 0);
    \draw[rarw, ->] (0, -1.5em) node[left]{$2^2=4$} -- (2, -1.5em);
    \draw[rarw, ->] (0, -3em) node[left]{$2^1=2$} -- (1, -3em);
    \draw[rarw, ->] (0, -4.5em) node[left]{$2^0=1$} -- (0.5, -4.5em);

    \coordinate (A) at (-4, -7em);
    \coordinate (B) at (4, -7em);
    \draw (A) -- (B);

    \foreach \i in {0, 1, 2, ..., 16} {
        \coordinate (ab\i) at ($(A)!\i/16!(B)$);
        \pgfmathtruncatemacro{\j}{\i - 8};
        \draw ($(ab\i) + (0, 2pt)$) node[above]{\j} -- ($(ab\i) - (0, 2pt)$);
    }

    \draw (-4, -8.5em) node[left]{$[0001]$};
    \draw[rarw, ->] (0, -8.5em) -- (0.5, -8.5em);
    \draw (-4, -10em) node[left]{$[0101]$};
    \draw[rarw, ->] (0, -10em) -- (2, -10em);
    \draw[rarw, ->] (2, -10em) -- (2.5, -10em);
    \coordinate (C) at ($(-4, -10em) - (0, 4mm)$);
    \draw (C) node[left]{$[1011]$};
    \draw[larw, <-] (C) -- ++(4, 0);
    \begin{scope}[transparency group, opacity=0.75]
        \draw[rarw, ->] ($(C) - (0, 2mm)$) -- ++(1, 0);
        \draw[rarw, ->] ($(C) - (-1, 2mm)$) -- ++(0.5, 0);
    \end{scope}
    \coordinate (D) at ($(C) - (0, 2mm) - (0, 1.5em)$);
    \draw (D) node[left]{$[1111]$};
    \draw[larw, <-] (D) -- ++(4, 0);
    \begin{scope}[transparency group, opacity=0.75]
        \draw[rarw, ->] ($(D) - (0, 2mm)$) -- ++(2, 0);
        \draw[rarw, ->] ($(D) - (-2, 2mm)$) -- ++(1, 0);
        \draw[rarw, ->] ($(D) - (-3, 2mm)$) -- ++(0.5, 0);
    \end{scope}

    \draw (ab3) -- ($(C) - (-1.5, 2mm)$);
    \draw (ab7) -- ($(D) - (-3.5, 2mm)$);
    \draw (ab8) -- ($(D) - (-4, 4mm)$);
    \draw (ab9) -- (0.5, -8.5em);
    \draw (ab13) -- (2.5, -10em);
\end{tikzfig}

考虑 $w$ 位补码所能表示的值的范围。它能表示的最小值是位向量 $[10\cdots0]$，其整数值为 $TMin_w \doteq -2^{w-1}$。而最大值是位向量 $[01\cdots1]$，其整数值为 $TMax_w \doteq \sum\limits_{i=0}^{w-2}2^i = 2^{w-1} - 1$。

同无符号一样，在可表示的取值范围内的每个数字都有一个唯一的 $w$ 位的补码编码。

\begin{theorem}[Uniqueness of two's-complement encoding]
    Function $B2T_w$ is a bijection.

    Vice versa, function $T2B_w$ is a bijection.
\end{theorem}

\subsection{有符号数和无符号数之间的转换}

将函数 $T2U_w$ 定义为 $T2U_w(x) \doteq B2U_w(T2B_w(x))$。这个函数的输入是一个 $TMin_w \~{} TMax_w$ 的数，输出是一个 $0 \~{} UMax_w$ 的值，输入和输出有相同的位表示。类似的，有函数 $U2T_w(x) \doteq B2T_w(U2B_w(x))$。

\begin{theorem}[Conversion from two's complement to unsigned]
    For $x$ such that $TMin \leq x \leq TMax_w$:
    \begin{equation}
        T2U_w(x) = \left\{
        \begin{array}{ll}
            x + 2^w, & x < 0 \\
            x, & x \geq 0
        \end{array}
        \right.
        \label{thm:t2u}
    \end{equation}
\end{theorem}

\begin{proof}[Conversion from two's complement to unsigned]
    Comparing Equations \eqref{def:b2u} and \eqref{def:b2t}, we can see that for bit pattern $\vec{x}$, if we compute the difference $B2U_w(\vec{x}) - B2T_w(\vec{x})$, the weighted sums for bits from $0$ to $w - 2$ will cancel each other, leaving a value $B2U_w(\vec{x}) - B2T_w(\vec{x}) = x_{w-1}(2^{w-1} - -2^{w-1}) = x_{w-1} 2^w$. This gives a relationship $B2U_w(\vec{x}) = B2T_w(\vec{x}) + x_{w-1}2^w$. We therefore have
    \begin{equation}
        B2U_w(T2B_w(x)) = T2U_w(x) = x + x_{w-1}w^2
        \label{proof:t2u}
    \end{equation}
    In a two's complement representation of $x$, bit $x_{w-1}$ determines whether or not $x$ is negative, giving the two cases of Equation \eqref{thm:t2u}.
\end{proof}

下图说明了函数 $T2U$ 的一般行为。如图所示，当将一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。

\begin{tikzfig}
    \tikzset{barw/.style={>={Triangle[length=2.5mm, width=6mm]}, line width=4mm, draw=White!30!Cerulean}};
    \tikzset{garw/.style={>={Triangle[length=2.5mm, width=6mm]}, line width=4mm, draw=White!30!gray}};
    \coordinate (A0) at (0, 1.5);
    \coordinate (B0) at (0, 0);
    \coordinate (C0) at (0, -1.5);
    \coordinate (A1) at (3, 3);
    \coordinate (B1) at (3, 1.5);
    \coordinate (C1) at (3, 0);
    \draw (A0) node[left] {$+2^{w-1}$};
    \draw (B0) node[left] {$0$};
    \draw (B0) node[left, align=right, xshift=-6em] {Two's\\[-0.3em]complement};
    \draw (C0) node[left] {$-2^{w-1}$};
    \draw (A0) -- (C0);
    \draw ($(A0) - (2pt, 0)$) -- ($(A0) + (2pt, 0)$);
    \draw ($(B0) - (2pt, 0)$) -- ($(B0) + (2pt, 0)$);
    \draw ($(C0) - (2pt, 0)$) -- ($(C0) + (2pt, 0)$);
    \draw (A1) node[right] {$2^w$};
    \draw (B1) node[right] {$2^{w-1}$};
    \draw (B1) node[right, xshift=6em] {Unsigned};
    \draw (C1) node[right] {$0$};
    \draw (A1) -- (C1);
    \draw ($(A1) - (2pt, 0)$) -- ($(A1) + (2pt, 0)$);
    \draw ($(B1) - (2pt, 0)$) -- ($(B1) + (2pt, 0)$);
    \draw ($(C1) - (2pt, 0)$) -- ($(C1) + (2pt, 0)$);
    \coordinate (D0) at ($(A0)!1/2!(B0)$);
    \coordinate (D1) at ($(B1)!1/2!(C1)$);
    \coordinate (E0) at ($(D0)!1/3!(D1)$);
    \coordinate (E1) at ($(D0)!2/3!(D1)$);
    \coordinate (F0) at ($(B0)!1/2!(C0)$);
    \coordinate (F1) at ($(A1)!1/2!(B1)$);
    \draw[garw, ->] (F0) -- (E0 |- F0) -- (E1 |- F1) -- (F1);
    \begin{scope}[transparency group, opacity=0.75]
        \draw[barw, ->] (D0) -- (D1);
    \end{scope}
\end{tikzfig}

反过来看，无符号数 $u$ 和与之对应的有符号数 $U2T_w{u}$ 之间的关系：

\begin{theorem}[Unsigned to two's complement conversion]
    For $u$ such that $0 \leq u \leq UMax_w$ :
    \begin{equation}
        U2T_w(u) = \left\{
        \begin{array}{ll}
            u, & u \leq TMax_w \\
            u - 2^w, & u > TMax_w
        \end{array}
        \right.
    \label{thm:u2t}
    \end{equation}
\end{theorem}

\begin{proof}[Unsigned to two's complement conversion]
    Let $\vec{u} = U2B_w(u)$. This bit vector will also be the two’s-complement representation of $U2T_w(u)$. Equations \eqref{def:b2u} and \eqref{def:b2t} can be combiened to give
    \begin{equation}
        U2T_w(u) = -u_{w-1}2^w + u
    \end{equation}
    In ths unsigned representation of $u$, bit $u_{w-1}$ determines whether or not $u$ is greater than $TMax_w = 2^{w-1} - 1$, giving the tow cases of Equation \eqref{thm:u2t}.
\end{proof}

下图说明了函数 $U2T$ 的行为。对于小的数($\leq TMax_w$)，从无符号到有符号的转换将保留数字的原值。对于大的数($> TMax_w$)，数字将转换为一个负数值。

\begin{tikzfig}
    \tikzset{barw/.style={>={Triangle[length=2.5mm, width=6mm]}, line width=4mm, draw=White!30!Cerulean}};
    \tikzset{garw/.style={>={Triangle[length=2.5mm, width=6mm]}, line width=4mm, draw=White!30!gray}};
    \coordinate (A0) at (0, 1.5);
    \coordinate (B0) at (0, 0);
    \coordinate (C0) at (0, -1.5);
    \coordinate (A1) at (3, 0);
    \coordinate (B1) at (3, -1.5);
    \coordinate (C1) at (3, -3);
    \draw (A0) node[left] {$2^w$};
    \draw (B0) node[left] {$2^{w-1}$};
    \draw (B0) node[left, xshift=-6em] {Unsigned};
    \draw (C0) node[left] {$0$};
    \draw (A0) -- (C0);
    \draw ($(A0) - (2pt, 0)$) -- ($(A0) + (2pt, 0)$);
    \draw ($(B0) - (2pt, 0)$) -- ($(B0) + (2pt, 0)$);
    \draw ($(C0) - (2pt, 0)$) -- ($(C0) + (2pt, 0)$);
    \draw (A1) node[right] {$+2^{w-1}$};
    \draw (B1) node[right] {$0$};
    \draw (B1) node[right, xshift=6em, align=left] {Two's\\[-0.3em]complement};
    \draw (C1) node[right] {$-2^{w-1}$};
    \draw (A1) -- (C1);
    \draw ($(A1) - (2pt, 0)$) -- ($(A1) + (2pt, 0)$);
    \draw ($(B1) - (2pt, 0)$) -- ($(B1) + (2pt, 0)$);
    \draw ($(C1) - (2pt, 0)$) -- ($(C1) + (2pt, 0)$);
    \coordinate (D0) at ($(B0)!1/2!(C0)$);
    \coordinate (D1) at ($(A1)!1/2!(B1)$);
    \coordinate (E0) at ($(D0)!1/3!(D1)$);
    \coordinate (E1) at ($(D0)!2/3!(D1)$);
    \coordinate (F0) at ($(A0)!1/2!(B0)$);
    \coordinate (F1) at ($(B1)!1/2!(C1)$);
    \draw[garw, ->] (F0) -- (E0 |- F0) -- (E1 |- F1) -- (F1);
    \begin{scope}[transparency group, opacity=0.75]
        \draw[barw, ->] (D0) -- (D1);
    \end{scope}
\end{tikzfig}

\subsection{C 语言中的有符号数与无符号数}

当声明一个像 \verb|12345| 或者 \verb|0x1A2B| 这样的常量时，这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符 ‘U’ 或者 ‘u’，例如，\verb|12345U| 或者 \verb|0x1A2Bu|。

C 语言执行一个运算时，如果它的一个操作数是有符号的而另一个是无符号的，那么就会隐式地把有符号操作数强制类型转换为无符号数，并假设两个数都是非负的，来执行这个运算。

\subsection{扩展一个数字的位表示}

要将一个无符号转换为一个更大的数据类型，只需简单地在二进制表示添加 leading zeros。这种操作被称为零扩展（zero extension）。

\begin{theorem}[Expansion of an unsigned number by zero externsion]
    Define bit vectors $\vec{u} = [u_{w-1}, u_{w-2}, \dots, u_0]$ of width $w$ and $\vec{u}' = [0, \dots, 0, u_{w-1}, u_{w-2}, \dots, u_0]$ of width $w'$, where $w' > w$. Then $B2U_w(\vec{u}) = B2U_{w'}(\vec{u}')$.
\end{theorem}

This theorem can be seen to follow directly from the definition of the unsigned encoding, given by Equation \eqref{def:b2u}.

要将一个补码数字转换为一个更大的数据类型，可以执行符号扩展（sign extension），在二进制表示添加 the most significant bit。

\begin{theorem}[Expansion of a two's complement number by sign extension]
    Define bit vectors $\vec{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$ of width $w$ and $\vec{x}' = [x_{w-1}, \dots, x_{w-1}, x_{w-1}, x_{w-2}, \dots, x_0]$ of width $w'$. Then $B2T_w(\vec{x}) = B2T_{w'}(\vec{x}')$.
\end{theorem}

\begin{proof}[Expansion of a two's complement number by sign extension]
    Let $w' = w + k$. What we want to prove is that
    \[
        B2T_{w+k}([\underbrace{x_{w-1}, \dots, x_{w-1}}_\text{$k$ times}, x_{w-1}, x_{w-2}, \dots, x_0]) = B2T_w([x_{w-1}, x_{w-2}, \dots, x_0])
    \]
    The proof follows by induction on $k$. That is, if we can prove that sign extending by 1 bit preserves the numeric value, then this property will hold when sign extending by an arbitray number of bits. Thus, the task reduces to proving that
    \[
        B2T_{w+1}([x_{w-1}, x_{w-1}, x_{w-2}, \dots, x_0]) = B2T_w([x_{w-1}, x_w{w-2}, \dots, x_0])
    \]
    Expanding the left-hand expression with Equation \eqref{def:b2t} gives the following:
    \begin{align*}
        B2T_{w+1}([x_{w-1}, x_{w-1}, x_{w-2}, \dots, x_0]) & = -x_{w-1}2^w + \sum\limits_{i=0}^{w-1}x_i2^i \\
        & = -x_{w-1}2^w + x_{w-1}2^{w-1} + \sum\limits_{i=0}^{w-2}x_i2^i \\
        & = -x_{w-1}(2^w - 2^{w-1}) + \sum\limits_{i=0}^{w-2}x_i2^i \\
        & = -x_{w-1}2^{w-1} + \sum\limits_{i=0}^{w-2}x_i2^i \\
        & = B2T_w([x_{w-1}, x_{w-2}, \dots, x_0])
    \end{align*}
    The key property we exploit is that $2^w - 2^{w-1} = 2^{w-1}$. Thus, the combined effect
    of adding a bit of weight $-2^w$ and of converting the bit having weight $-2^{w-1}$ to be
    one with weight $2^{w-1}$ is to preserve the original numeric value.
\end{proof}

\subsection{截断数字}

当将一个 $w$ 位的数 $\vec{x} = [x_{w-1}, x_{w-2}, \dots, x_0]$ 截断为一个 $k$ 位数字时，会丢弃高 $w-k$ 位，得到一个位向量 $\vec{x}' = [x_{k-1}, x_{k-2}, \dots, x_0]$。截断一个数字可能会改变它的值——溢出的一种形式。对于一个无符号数，可以很容易得出其数值结果。

\begin{theorem}[Truncation of an unsigned number]
    Let $\vec{x}$ be the bit vector $[x_{w-1}, x_{w-2}, \dots, x_0]$, and let $\vec{x}$ be the result of truncating it to $k$ bits: $\vec{x}' = [x_{k-1}, x_{k-2}, \dots, x_0]$. Let $x = B2U_w(\vec{x})$ and $x' = B2U_k(\vec{x}')$. The $x' = x \bmod 2^k$.
\end{theorem}

该定理背后的直觉就是所有被截取的位其权重形式都为 $2^i$，其中 $i \geq k$，因此，每一个权在取模操作下结果都为零。

\begin{proof}[Truncation of an unsigned number]
    Applying the modulus operation to Equation \eqref{def:b2u} yields
    \begin{align*}
        B2U_w(x_{w-1}, x_{w-2}, \dots, x_0]) \bmod 2^k & = \Bigl[\sum\limits_{i=0}^{w-1}x_i2^i\Bigr] \bmod 2^k \\
        & = \Bigl[\sum\limits_{i=0}^{k-1}x_i2^i\Bigr] \bmod 2^k \\
        & = \sum\limits_{i=0}^{k-1}x_i2^i \\
        & = B2U_k([x_{k-1}, x_{k-2}, \dots, x_0])
    \end{align*}
    In this derivation, we make use of the property that $2^i \bmod 2^k = 0$ for any $i \geq k$.
\end{proof}

补码截断也具有类似的属性，只不过要将最高位转换为符号位。

\begin{theorem}[Truncation of a two's complement number]
    Let $\vec{x}$ be the bit vector $[x_{w-1}, x_{w-2}, \dots, x_0]$, and let $\vec{x}'$ be the reuslt of truncating it to $k$ bits: $\vec{x}' = [x_{k-1}, x_{k-2}, \dots, x_0]$. Let $ x= B2T_w(\vec{x})$ and $x' = B2T_k(\vec{x}')$. The $x' = U2T_k(x \bmod 2^k)$.
\end{theorem}

在这个公式中，$x \bmod 2^k$ 将是 $0 \~{} 2^{k-1}$ 之间的一个数。对其应用函数 $U2T_k$ 产生的结果是把最高有效位 $x_{k-1}$ 的权重从 $2_{k-1}$ 转变为 $-2^{k-1}$。

\begin{proof}[Truncation of a two's complement number]
    Using a similar argument to the one we used for truncation of an unsigned number shows that
    \[
        B2T_w([x_{w-1}, x_{w-2}, \dots, x_0]) \bmod 2^k = B2U_k([x_{k-1}, x_{k-2}, \dots, x_0])
    \]
    That is, $x \bmod 2^k$ can be be represented by an unsigned number having bit-level representation $[x^{k-1}, x^{k-2}, \dots, x_0]$. Converting this to a two’s-complement number gives $x' = U2T_k(x \bmod 2^k)$.
\end{proof}

总而言之，无符号数的截断结果是：
\begin{equation}
    B2U_k[x_{k-1}, x_{k-2}, \dots, x_0] = B2U_w([x_{w-1}, x_{w-2}, \dots, x_0]) \bmod 2^k
    \label{eq:truncu}
\end{equation}
补码的截断结果是：
\begin{equation}
    B2T_k[x_{k-1}, x_{k-2}, \dots, x_0] = U2T_k(B2U_w([x_{w-1}, x_{w-2}, \dots, x_0]) \bmod 2^k)
    \label{eq:truncs}
\end{equation}

\subsection{关于有符号数与无符号数的建议}

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差别的错误很难被发现。

\section{整数运算}

\subsection{无符号加法}

考虑两个非负整数 $x$ 和 $y$，满足 $0 \leq x, y < 2^w$。每个数都能表示为 $w$ 位无符号数字。然而，如果计算它们的和，可能的范围就为 $0 \leq x + y \leq 2^{w+1} - 2$。表示这个和可能需要 $w+1$ 位，超过了 $w$ 位的表示范围，需要将超过的位数丢弃。

\begin{theorem}[Unsigned addition]
    For $x$ and $y$ such that $0 \leq x, y < 2^w$:
    \begin{equation}
        x +_w^u y = \left\{
        \begin{array}{lll}
            x + y, & x + y < 2^w & \text{Normal} \\
            x + y - 2^w, & 2^w \leq x+y < 2^{w+1} & \text{Overflow}
        \end{array}
        \right.
        \label{thm:addu}
    \end{equation}
\end{theorem}

下图说明了 Equation \eqref{thm:addu} 的这两种情况。

\begin{tikzfig}
    \tikzset{barw/.style={>={Triangle[length=2.5mm, width=6mm]}, line width=4mm, draw=White!30!Cerulean}};
    \tikzset{garw/.style={>={Triangle[length=2.5mm, width=6mm]}, line width=4mm, draw=White!30!gray}};
    \coordinate (A0) at (0, 3);
    \coordinate (B0) at (0, 1.5);
    \coordinate (C0) at (0, 0);
    \coordinate (A1) at (3, 1.5);
    \coordinate (B1) at (3, 0);
    \draw (A0) node[left]{$2^{w+1}$};
    \draw (A0) node[above]{$x+y$};
    \draw (B0) node[left]{$2^w$};
    \draw (C0) node[left]{$0$};
    \draw (A1) node[above]{$x+^uy$};
    \draw ($(A0) - (2pt, 0)$) -- ($(A0) + (2pt, 0)$);
    \draw ($(B0) - (2pt, 0)$) -- ($(B0) + (2pt, 0)$);
    \draw ($(C0) - (2pt, 0)$) -- ($(C0) + (2pt, 0)$);
    \draw ($(A1) - (2pt, 0)$) -- ($(A1) + (2pt, 0)$);
    \draw ($(B1) - (2pt, 0)$) -- ($(B1) + (2pt, 0)$);
    \draw (A0) -- (C0);
    \draw (A1) -- (B1);

    \coordinate (D0) at ($(A0)!1/2!(B0)$);
    \coordinate (D1) at ($(A1)!1/2!(B1)$);
    \coordinate (E0) at ($(C0)!1/3!(B1)$);
    \coordinate (E1) at ($(C0)!2/3!(B1)$);
    \coordinate (F0) at ($(B0)!1/3!(C0)$);
    \coordinate (F1) at ($(A1)!1/3!(B1)$);
    \draw[garw, ->] (D0) -- (E0 |- D0) node[above]{Overflow} -- (E1 |- D1) -- (D1);
    \begin{scope}[transparency group, opacity=0.75]
        \draw[barw, ->] (F0) -- (E0 |- F0) node[below]{Normal} -- (F1);
    \end{scope}
\end{tikzfig}

\begin{proof}[Unsigned addition]
    In general, we can see that if $x + y < 2^w$, the leading bit in the ($w + 1$)-bit representation of the sum will equal $0$, and hence discarding it will not change the numeric value. On the other hand, if $2^w \leq x + y < 2^{w+1}$, the leading bit in the ($w + 1$)-bit representation of the sum will equal $1$, and hence discarding it is equivalent to subtracting $2^w$ from the sum.
\end{proof}

说一个算术运算溢出，是指完整的整数结果不能存放到数据类型的字长限制中去。如 Equation \eqref{thm:addu} 所示，当两个操作数的和为 $2^w$ 或者更大时，就发生了溢出。

当执行 C 程序时，不会将溢出作为错误而发出信号。不过有的时候，我们可能希望判定是否发出了溢出。

\begin{theorem}[Detecting overflow of unsigned addition]
    For $x$ and $y$ in the range $0 \leq x, y \leq UMax_w$, let $s \doteq x +_w^u y$. Then the computation of $s$ overflowed if and only if $s < x$ (or equivalently, $s < y$).
\end{theorem}

\begin{proof}[Detecting overflow of unsigned addition]
    Observe that $x + y \geq x$, and hence if $s$ did not overflow, we will surely have $s \geq x$. On the other hand, if $s$ did overflow, we have $s = x + y - 2^w$. Given that $y < 2^w$, we have $y - 2^w < 0$, and hence $s = x + (y - 2^w) < x$.
\end{proof}

模数加法是一个阿贝尔群（Abelian group），具有可交换和可结合的性质。它有一个单位元 $0$，并且每个元素有一个加法逆元。考虑 $w$ 位的无符号数的集合，执行加法运算 $+^u_w$。对于每个值 $x$，必然有某个值 $-^u_wx$ 满足 $-^u_wx +^u_wx = 0$。

\begin{theorem}[Unsigned negation]
    For any number $x$ such that $0 \leq x < 2^w$, its $w$-bit unsigned negation $-^u_wx$ is given by following:
    \begin{equation}
        -^u_wx = \left\{
        \begin{array}{ll}
            x, & x = 0 \\
            2^w - x, & x > 0
        \end{array}
        \right.
        \label{thm:negu}
    \end{equation}
\end{theorem}

\begin{proof}[Unsigned negation]
    When $x = 0$, the additive inverse is clearly $0$. For $x > 0$, consider the value $2^w - x$. Observe that this number is in the range $ 0 < 2^w - x < 2^w$. We can also see that $(x + 2^w -x ) \bmod 2^w = 2^w \bmod 2^w = 0$. Hence it is the inverse of $x$ under $+^u_w$.
\end{proof}

\subsection{补码加法}

对于补码加法，需要确定当结果太大或者太小时的处理方式。给定在范围 $-2^{w-1} \leq x, y \leq 2^{w-1}$ 之内的整数值 $x$ 和 $y$，它们的和就在范围 $-2^w \leq x + y \leq 2^w - 2$ 之内，要想准确表示，可能需要 $w + 1$ 位。需要将二进制表示阶段到 $w$ 位，来避免数据大小的不断扩张。

\begin{theorem}[Two's-complement addition]
    For integer values $x$ and $y$ in the range $-2^{w-1} \leq x, y \leq 2^{w-1}-1$:
    \begin{equation}
        x +^t_w y = \left\{
        \begin{array}{lll}
            x + y - 2^w, & 2^{w-1} \leq x + y & \text{Positive overflow} \\
            x + y, & -2^{w-1} \leq x + y < 2^{w-1} & \text{Nromal} \\
            x + y + 2^w, & x + y < -2^{w-1} & \text{Negative overflow}
        \end{array}
        \right.
        \label{thm:adds}
    \end{equation}
\end{theorem}

下图说明了这个定理。当和 $x+y$ 超过 $TMax_w$ 时，发生了正溢出，这种情况下，截断的结果是从和中减去 $2^w$；当和 $x+y$ 小于 $TMin_w$ 时，发生了负溢出，这种情况下，截断的结果是把和加上 $2^w$。

\begin{tikzfig}
    \tikzset{barw/.style={>={Triangle[length=2.5mm, width=6mm]}, line width=4mm, draw=White!30!Cerulean}};
    \tikzset{garw/.style={>={Triangle[length=2.5mm, width=6mm]}, line width=4mm, draw=White!30!gray}};
    \coordinate (A) at (0, 3);
    \coordinate (B) at (0, -3);
    \coordinate (C) at (3, 1.5);
    \coordinate (D) at (3, -1.5);

    \foreach \i in {0, 1, 2, 3, 4} {
        \coordinate (ab\i) at ($(A)!\i/4!(B)$);
        \draw ($(ab\i) - (2pt, 0)$) -- ($(ab\i) + (2pt, 0)$);
    }

    \foreach \i in {0, 1, 2} {
        \coordinate (cd\i) at ($(C)!\i/2!(D)$);
        \draw ($(cd\i) - (2pt, 0)$) -- ($(cd\i) + (2pt, 0)$);
    }

    \draw (ab0) node[above]{$x+y$};
    \draw (ab0) node[left]{$+2^w$};
    \draw (ab1) node[left]{$+2^{w-1}$};
    \draw (ab2) node[left]{$0$};
    \draw (ab2) node[right]{Normal};
    \draw (ab3) node[left]{$-2^{w-1}$};
    \draw (ab4) node[left]{$-2^w$};
    \draw (cd0) node[above]{$x+^ty$};
    \draw (cd0) node[right]{$+2^{w-1}$};
    \draw (cd1) node[right]{$0$};
    \draw (cd2) node[right]{$-2^{w-1}$};
    \draw (A) -- (B);
    \draw (C) -- (D);

    \coordinate (E0) at ($(ab1)!1/2!(ab2)$);
    \coordinate (E1) at ($(cd0)!1/2!(cd1)$);
    \coordinate (F0) at ($(ab2)!1/2!(ab3)$);
    \coordinate (F1) at ($(cd1)!1/2!(cd2)$);
    \coordinate (G0) at ($(ab0)!1/2!(ab1)$);
    \coordinate (G1) at ($(cd1)!2/3!(cd2)$);
    \coordinate (H0) at ($(ab3)!1/2!(ab4)$);
    \coordinate (H1) at ($(cd0)!2/3!(cd1)$);
    \coordinate (T0) at ($(ab2)!1/3!(cd1)$);
    \coordinate (T1) at ($(ab2)!2/3!(cd2)$);

    \draw (G0) node[left, xshift=-3em]{Case 4};
    \draw (H0) node[left, xshift=-3em]{Case 3};
    \draw (E0) node[left, xshift=-3em]{Case 2};
    \draw (F0) node[left, xshift=-3em]{Case 1};
    \draw (T0 |- G0) node[above, xshift=2em, yshift=0.4em]{Positive overflow};
    \draw (T0 |- H0) node[below, xshift=2em, yshift=-0.4em]{Negative overflow};

    \draw[garw, ->, draw=White!30!Black] (G0) -- (T0 |- G0) -- (T1 |- G1) -- (G1);
    \begin{scope}[transparency group, opacity=0.75]
        \draw[garw, ->] (H0) -- (T0 |- H0) -- (T1 |- H1) -- (H1);
    \end{scope}
    \begin{scope}[transparency group, opacity=0.75]
        \draw[barw, ->] (E0) -- (E1);
        \draw[barw, ->] (F0) -- (F1);
    \end{scope}
\end{tikzfig}

两个数的 $w$ 位补码之和与无符号之和在二进制表示上完全相同。

\begin{proof}[Two's-complement addition]
    Since two’s-complement addition has the exact same bit-level representation as unsigned addition, we can characterize the operation $+^t_w$ as one of converting its arguments to unsigned, performing unsigned addition, and then converting back to two’s complement:
    \[
        x +^t_w y = U2T_w(T2U_w(x) +^u_w T2U_w(y))
    \]

    By Equation \eqref{proof:t2u} we can write $T2U_w(x)$ as $x_{w-1}2^w + x$ and $T2U_w(y)$ as $y_{w-1}2^w + y$. Using the property that $+_w$ the properties of modular addition, we then have
    \begin{align*}
        x +^t_w y & = U2T_w(T2U_w(x) +^u_w T2U_w(y)) \\
                  & = U2T_w[(x_{w-1}2^w + x + y_{w-1}2^w + y) \bmod 2^w] \\
                  & = U2T_w[(x + y) \bmod 2^w]
    \end{align*}
    The terms $x_{w−1}2^w$ and $y_{w−1}2^w$ drop out since they equal $0$ modulo $2^w$ .

    To better understand this quantity, let us define $z$ as the integer sum $z \doteq x + y$, $z'$ as $z' \doteq z \bmod 2^w$, and $z''$ as $z'' \doteq U2T_w(z')$. The value $z''$ is equal to $x +^t_w y$. We can divide the analysis into four cases as illustrated in above Figure:
    \begin{enumerate}
        \item $-2^w \leq z < -2^{w-1}$. Then we will have $z' = z + 2^w$. This gives $0 \leq z' < -2^{w-1} + 2^w = 2^{w-1}$. Examining Equation \eqref{thm:u2t}, we see that $z'$ is in the range sunch that $z'' = z'$. This is the of negative overflow. We have added two negative numbers $x$ and $y$ (that’s the only way we can have $z < −2^{w−1}$) and obtained a nonnegative result $z''  = x + y + 2^w$.
        \item $-2^{w-1} \leq z < 0$. Then we will again have $z' = z + 2^w$, giving $-2^{w-1} + 2^w = 2^{w-1} \leq z' < 2^w$. Examining Equation \eqref{thm:u2t}, we see that $z'$ is in such a range that $z'' = z' - 2^w$, and therefore $z'' = z' - 2^w = z + 2^w - 2^w = z$. That is, our two’s-complement sum $z$ equals the integer sum $x + y$.
        \item $0 \leq z < 2^{w-1}$. Then we will have $z' = z$, giving $0 \leq z' < 2^{w−1}$, and hence $z'' = z' = z$. Again, the two’s-complement sum $z$ equals the integer sum $x + y$.
        \item $2^{w-1} \leq z < 2^w$. We will again have $z' = z$, giving $2^{w−1} \leq z' < 2^w$. But in this range we have $z'' = z' − 2^w$, giving $z'' = x + y − 2^w$. This is the case of positive overflow. We have added two positive numbers $x$ and $y$ (that’s the only way we can have $z \geq 2^{w−1}$) and obtained a negative result $z'' = x + y − 2^w$.
    \end{enumerate}
\end{proof}

\begin{theorem}[Detecting overflow of two's-complement addition]
    For $x$ and $y$ in the range $TMin_w \leq x, y \leq TMax_w$, let $s \doteq x +^t_w y$. Then the computation of $s$ has had positive overflow if and only if $x > 0$ and $y > 0$ but $s \leq 0$. The computation has had negative overflow if and only if $x < 0$ and $y < 0$ but $s \geq 0$.
\end{theorem}

\begin{proof}[Detecting overflow of tow's-compelmet addition]
    Let us first do the analysis for positive overflow. If both $x > 0$ and $y > 0$ but $s \leq 0$, then clearly positive overflow has occurred. Conversely, positive overflow requires (1) that $x > 0$ and $y > 0$ (otherwise, $x + y < TMax_w$ ) and (2) that $s ≤ 0$ (from Equation \eqref{thm:adds}). A similar set of arguments holds for negative overflow.
\end{proof}

\subsection{补码的非}

可以看到范围在 $TMin_w \leq x \leq TMax_w$ 中的每个数字 $x$ 都有 $+^t_w$ 下的加法逆元，将 $-^t_w$ 表示如下。

\begin{theorem}[Two's-complement negation]
    For $x$ in the range $TMin_w \leq x \leq TMax_w$, its two's complement negation $-^t_w x$ is given by the formula
    \begin{equation}
        -^t_w x = \left\{
        \begin{array}{ll}
            TMin_w, & x = TMin_w \\
            -x, & x > TMin_w
        \end{array}
        \right.
    \label{thm:negs}
    \end{equation}
\end{theorem}

也就是说，对于 $w$ 位的补码加法来说，$TMin_w$ 是自己的加法的逆，而对其他任何数值 $x$ 都有 $-x$ 作为其加法的逆。

\begin{proof}[Two's-complement negation]
    Observe that $TMin_w + TMin_w = −2^{w−1} + −2^{w−1} = −2^w$. This would cause negative overflow, and hence $TMin_w +^t_w TMin_w = −2^w + 2^w = 0$. For values of $x$ such that $x > TMin_w$, the value $−x$ can also be represented as a $w$-bit two’s-complement number, and their sum will be $−x + x = 0$.
\end{proof}

\subsection{无符号乘法}

范围在 $0 \leq x, y \leq 2^w - 1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的无符号数，但是它们的乘积 $x \cdot y$ 的取值范围为 $0$ 到 $(2^w - 1)^2 = 2^{2w} - 2^{w+1} + 1$ 之间。这可能需要 $2w$ 位来表示。C 语言中的无符号乘法被定义为产生 $w$ 位的值，也就是 $2w$ 位的整数乘积的低 $w$ 位表示的值。我们将这个值表示为 $x *^u_w y$。

\begin{theorem}[Unsigned multiplication]
    For $x$ and $y$ such that $0 \leq x, y \leq UMax_w$:
    \begin{equation}
        x *^u_w y = (x \cdot y) \bmod 2^w
        \label{thm:mulu}
    \end{equation}
\end{theorem}

\subsection{补码乘法}

范围在 $-2^{w-1} \leq x, y \leq 2^{w-1} - 1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的补码数字，但是它们的乘积 $x \cdot y$ 的取值范围为 $-2^{w-1} \cdot (2^{w-1} - 1) = -2^{2w-2} + 2^{w-1}$ 到 $-2^{w-1} \cdot -2^{w-1} = -2^{2w-2}$ 之间。要想用补码表示这个乘积，可能需要 $2w$ 位。C 语言中的有符号乘法是通过将 $2w$ 位的乘积截断为 $w$ 位来实现的。我们将这个数值表示为 $*^t_w$。将一个补码数阶截断为 $w$ 位相当于先计算该值模 $2^w$，再把无符号数转换为补码。

\begin{theorem}[Two's-compelment multiplication]
    For $x$ and $y$ such that $TMin_w \leq x, y \leq TMax_w$:
    \begin{equation}
        x *^t_w y = U2T_w((x \cdot y) \bmod 2^w)
        \label{thm:muls}
    \end{equation}
\end{theorem}

我们认为对于无符号和补码乘法来说，乘法运算的二进制表示是一样的。

\begin{theorem}[Bit-level equivalence of unsigned and two's-complement multiplication]
    Let $\vec{x}$ and $\vec{y}$ be bit vectors of length $w$. Define integers $x$ and $y$ as the values represented by these bits in two's-complement form: $x = B2T_w(\vec{x})$ and $y = B2T_w(\vec{y})$. Define nonnegative integers $x'$ and $y'$ as the values represented by these bits in unsigned form: $x' = B2U_w(\vec{x})$ and $y' = B2U_w(\vec{y})$. Then
    \[
        T2B_w(x *^t_w y) = U2B_w(x' *^u_w y')
    \]
\end{theorem}

\begin{proof}[Bit-level equivalence of unsigned and two's-complement multiplication]
    From Equation \eqref{proof:t2u}, we have $x' = x + x_{w-1}2^w$ and $y' = y + y_{w-1}2^w$. Computing the product of these values modulo $2_w$ gives the following:
    \begin{equation}
        \begin{aligned}
            (x' \cdot y') \bmod 2_w & = [(x + x_{w-1}2^w) \cdot (y + y_{w-1}2^w)] \bmod 2^w \\
            & = [x \cdot y + (x_{w-1}y + y_{w-1}x)2^w + x_{w-1}y_{w-1}2^{2w}] \bmod 2_w \\
            &= (x \cdot y) \bmod 2^w
        \end{aligned}
        \label{eq:x'y'mod}
    \end{equation}
    The terms with weight $2^w$ and $2^{2w}$ drop out due to the modulus operator. By Equation \eqref{thm:muls}, we have $x *^t_w y = U2T_w((x \cdot y) \bmod 2^w)$. We can apply the operation $T2U_w$ to both sides to get
    \[
        T2U_w(x *^t_w y) = T2U_w(U2T_w((x \cdot y) \bmod 2^w)) = (x \cdot y) \bmod 2^w
    \]
    Combining this result with Equations \eqref{thm:mulu} and \eqref{eq:x'y'mod} shows that $T2U_w(x *^t_w y) = (x' \cdot y') \bmod 2^w = x' *^t_w y'$. We can then apply $U2B_w$ to both sides to get
    \[
        U2B_w(T2U_w(x *^t_w y)) = T2B(x *^t_w y) = U2B(x' *^u_w y')
    \]
\end{proof}

\subsection{乘以常数}

在大多数机器上，乘法运算指令比其他整数运算指令要慢。因此，编译期使用了一项重要的优化，用移位和加法运算的组合来代替乘以常数的乘法。首先，考虑乘以 $2$ 的幂的情况。

\begin{theorem}[Multiplication by a power of 2]
    Let $x$ be the unsigned integer represented by bit pattern $[x_{w-1}, x_{w-2}, \dots, x_0]$. Then for any $k \geq 0$, the $w + k$-bit unsigned representation of $x2^k$ is given by $[x_{w-1}, x_{w-2}, \dots, x_0, 0, \dots, 0]$, where $k$ zeros have benn added to the right.
\end{theorem}

\begin{proof}[Multiplication by a power of 2]
    This property can be derived using Equation \eqref{def:b2u}:
    \begin{align*}
        B2U_{w+k}([x_{w-1}, x_{w-2}, \dots, x_0, 0, \dots, 0]) &= \sum\limits_{i=0}^{w-1}x_i2^{i+k} \\
        & = \Bigl[\sum\limits_{i=0}^{w-1}x_i2^i\Bigr] \cdot 2^k \\
        &= x2^k
    \end{align*}
\end{proof}

当对固定字长左移 $k$ 位时，其高 $k$ 位被丢弃，得到 $[x_{w-k-1}, x_{w-k-2}, \dots, x_0, 0, \dots, 0]$，而执行固定字长的乘法也是这种情况。因此，我们可以看出左移一个数值等价于执行一个与 $2$ 的幂相乘的无符号乘法。

\begin{theorem}[Unsigend multiplication by a power of 2]
    For C variables \verb|x| and \verb|k| with unsigned values $x$ and $k$, such that $0 \leq k < w$, the C expression \verb|x << k| yields the value $x *^u_w 2^k$.
\end{theorem}

由于固定大小的补码算数运算的位级操作与其无符号运算等价，因此有类似表述。

\begin{theorem}[Two's-complement multiplication by a power of 2]
    For C variables \verb|x| and \verb|k| with two's-complement value $x$ and unsigend value $k$, such that $0 \leq k < w$, the C expression \verb|x << k| yields the value $x *^t_w 2^k$.
\end{theorem}

由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。例如，假设一个程序包含表达式 \verb|x * 14|。利用 $14 = 2^3 + 2^2 + 2^1$，编译器会将乘法重写为 \verb|(x << 3) + (x << 2) + (x << 1)|，将一个乘法替换为三个移位和两个加法。编译器还可以利用 $14 = 2^4 - 2^1$，将乘法重写为 \verb|(x << 4) - (x << 1)|，这时只需要两个移位和一个减法。

\subsection{除以 2 的幂}

在大多数机器上，整数除法要比整数乘法更慢，除以 2 的幂也可以用移位运算来实现，只不过用的是右移，无符号和补码数分别使用逻辑移位和算数移位。

整数除法总是舍入到 0。为了精确定义，需要引入一些符号。

\begin{definition}[Floor of a number]
    For any real number $a$, define $\lfloor a \rfloor$ to be the unique integer $a'$ such that $a' \leq a < a' + 1$.
\end{definition}

\begin{definition}[Ceil of a number]
    For any real number $a$, define $\lceil a \rceil$ to be the unique integer $a'$ such that $a' - 1 < a \leq a'$.
\end{definition}

\begin{theorem}[Unsigend division by a power of 2]
    For C variables \verb|x| and \verb|k| with unsigned values $x$ and $k$, such that $0 \leq k < w$, the C expression \verb|x >> k| yields the value $\lfloor x / 2^k \rfloor$.
\end{theorem}

\begin{proof}[Unsigned division by a power of 2]
    Let $x$ be the unsigned integer represented by bit pattern $[x_{w-1}, x_{w-2}, \dots, x_0]$, and let $k$ in the range $0 \leq k < w$. Let $x'$ be the unsigned number with $w-k$-bit representation $[x_{w-1}, x_{w-2}, \dots, x_k]$, and let $x''$ be the unsigned number with $k$-bit representation $[x_{k-1}, \dots, x_0]$. We can therefore see that $x = 2^k x' + x''$, and that $0 \leq x'' < 2^k$. It therefore follows that $\lfloor x / 2^k \rfloor = x'$.

    Performing a logical right shift of bit vector $[x_{w-1}, x_{w-2}, \dots, x_0]$ by $k$ yields the bit vector $[0, \dots, 0, x_{w-1}, x_{w-2}, \dots, x_0]$. This it vector has numeric value $x'$, which we have seen is the value that would result by computing the expression \verb|x >> k|.
\end{proof}

对于除以 2 的幂的补码除法来说，情况要稍微复杂一些，为了保证负数仍然为负，移位要执行的是算术右移。

\begin{theorem}[Two's-complement division by a power of 2, rounding down]
    Let C variables \verb|x| and \verb|k| have two’s-complement value $x$ and unsigned value $k$, respectively, such that $0 \leq k < w$. The C expression \verb|x >> k|, when the shift is performed arithmetically, yields the value $\lfloor x / 2^k \rfloor$.
\end{theorem}

\begin{proof}[Two's-complement division by a power of 2, rounding down]
    Let $x$ be the two’s-complement integer represented by bit pattern $[x_{w−1}, x_{w−2}, \dots, x_0]$, and let $k$ be in the range $0 \leq k < w$. Let $x'$ be the two’s-complement number represented by the $w−k$ bits $[x_{w−1}, x_{w−2}, \dots, x_k]$, and let $x''$ be the unsigned number represented by the low-order $k$ bits $[x_{k−1}, \dots, x_0]$. By a similar analysis as the unsigned case, we have $x = 2^kx' + x''$ and $0 \leq x  < 2^k$, giving $x'' = \lfloor x / 2^k \rfloor$. Furthermore, observe that shifting bit vector $[x_{w−1}, x_{w−2}, \dots, x_0]$ right arithmetically by $k$ yields the bit vector $[x_{w−1}, \dots, x_{w−1}, x_{w−1}, x_{w−2}, \dots, x_k]$ which is the sign extension from $w − k$ bits to $w$ bits of $[x_{w−1}, x_{w−2}, \dots, x_k]$. Thus, this shifted bit vector is the two’s-complement representation of $\lfloor x / 2^k \rfloor$.
\end{proof}

对于 $x \geq 0$，变量 \verb|x| 的最高有效位是 0,所以效果与逻辑右移是一样的。因此，对于非负数来说，算术右移 $k$ 位与除以 $2^k$ 是一样的。对于负数而言，当需要舍入时，移位会导致结果向下舍入。需要调整策略来处理负数的情况。

\begin{theorem}[Two's-complement division by a power of 2, rounding up]
    Let C variables \verb|x| and \verb|k| have two’s-complement value $x$ and unsigned value $k$, respectively, such that $0 \leq k < w$. The C expression \verb|(x + (1 << k) - 1) >> k|, when the shift is performed arithmetically, yields the value $\lceil x / 2^k \rceil$.
\end{theorem}

\begin{proof}[Two's-complement division by a power of 2, rounding up]
    To see that $\lceil x / y \rceil = \lfloor (x + y − 1)/y \rfloor$, suppose that $x = qy + r$, where $0 \leq r < y$, giving $(x + y − 1) / y = q + (r + y − 1) / y$, and so $\lfloor (x + y − 1) / y \rfloor = q + \lfloor (r + y − 1) / y \rfloor$. The latter term will equal $0$ when $r = 0$ and $1$ when $r > 0$. That is, by adding a bias of $y − 1$ to $x$ and then rounding the division downward, we will get $q $when $y$ divides $x$ and $q + 1$ otherwise.

    Returning to the case where $y = 2^k$, the C expression \verb|x + (1 << k) - 1| yields the value $x + 2^k − 1$. Shifting this right arithmetically by $k$ therefore yields $\lceil x / 2^k \rceil$.
\end{proof}

综上，对于使用算术右移的补码机器，C 表达式 \verb|(x < 0 ? x + (1 << k) - 1 : x) >> k)| 将会计算数值 $x / 2^k$。

同乘法不同，我们不能用除以 2 的幂的除法来表示除以任意常数 $K$ 的除法。

\subsection{关于整数运算的最后思考}

正如我们看到的，计算机执行的“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。我们还看到，补码表示提供了一种既能表示负数也能表示正数的灵活方式，同时使用了与执行无符号算术相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者类似的位级行为。

\endinput
